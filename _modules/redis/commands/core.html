<!doctype html>
<html class="no-js" lang="zh-CN" data-content_root="../../../">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><link rel="index" title="索引" href="../../../genindex.html" /><link rel="search" title="搜索" href="../../../search.html" />

    <!-- Generated with Sphinx 8.1.3 and Furo 2024.08.06 -->
        <title>redis.commands.core - redis-py 5.1.1 文档</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=a746c00c" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo.css?v=354aac6f" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery.css?v=d2d258e8" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo-extensions.css?v=302659d7" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-with-moon" viewBox="0 0 24 24">
    <title>Auto light/dark, in light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path style="opacity: 50%" d="M 5.411 14.504 C 5.471 14.504 5.532 14.504 5.591 14.504 C 3.639 16.319 4.383 19.569 6.931 20.352 C 7.693 20.586 8.512 20.551 9.25 20.252 C 8.023 23.207 4.056 23.725 2.11 21.184 C 0.166 18.642 1.702 14.949 4.874 14.536 C 5.051 14.512 5.231 14.5 5.411 14.5 L 5.411 14.504 Z"/>
      <line x1="14.5" y1="3.25" x2="14.5" y2="1.25"/>
      <line x1="14.5" y1="15.85" x2="14.5" y2="17.85"/>
      <line x1="10.044" y1="5.094" x2="8.63" y2="3.68"/>
      <line x1="19" y1="14.05" x2="20.414" y2="15.464"/>
      <line x1="8.2" y1="9.55" x2="6.2" y2="9.55"/>
      <line x1="20.8" y1="9.55" x2="22.8" y2="9.55"/>
      <line x1="10.044" y1="14.006" x2="8.63" y2="15.42"/>
      <line x1="19" y1="5.05" x2="20.414" y2="3.636"/>
      <circle cx="14.5" cy="9.55" r="3.6"/>
    </svg>
  </symbol>
  <symbol id="svg-moon-with-sun" viewBox="0 0 24 24">
    <title>Auto light/dark, in dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path d="M 8.282 7.007 C 8.385 7.007 8.494 7.007 8.595 7.007 C 5.18 10.184 6.481 15.869 10.942 17.24 C 12.275 17.648 13.706 17.589 15 17.066 C 12.851 22.236 5.91 23.143 2.505 18.696 C -0.897 14.249 1.791 7.786 7.342 7.063 C 7.652 7.021 7.965 7 8.282 7 L 8.282 7.007 Z"/>
      <line style="opacity: 50%" x1="18" y1="3.705" x2="18" y2="2.5"/>
      <line style="opacity: 50%" x1="18" y1="11.295" x2="18" y2="12.5"/>
      <line style="opacity: 50%" x1="15.316" y1="4.816" x2="14.464" y2="3.964"/>
      <line style="opacity: 50%" x1="20.711" y1="10.212" x2="21.563" y2="11.063"/>
      <line style="opacity: 50%" x1="14.205" y1="7.5" x2="13.001" y2="7.5"/>
      <line style="opacity: 50%" x1="21.795" y1="7.5" x2="23" y2="7.5"/>
      <line style="opacity: 50%" x1="15.316" y1="10.184" x2="14.464" y2="11.036"/>
      <line style="opacity: 50%" x1="20.711" y1="4.789" x2="21.563" y2="3.937"/>
      <circle style="opacity: 50%" cx="18" cy="7.5" r="2.169"/>
    </svg>
  </symbol>
  <symbol id="svg-pencil" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-pencil-code">
      <path d="M4 20h4l10.5 -10.5a2.828 2.828 0 1 0 -4 -4l-10.5 10.5v4" />
      <path d="M13.5 6.5l4 4" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
  <symbol id="svg-eye" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-eye-code">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0" />
      <path
        d="M11.11 17.958c-3.209 -.307 -5.91 -2.293 -8.11 -5.958c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6c-.21 .352 -.427 .688 -.647 1.008" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>

<a class="skip-to-content muted-link" href="#furo-main-content">Skip to content</a>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../../index.html"><div class="brand">redis-py 5.1.1 文档</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
          <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon no-toc" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../../../index.html">
  
  <div class="sidebar-logo-container">
    <img class="sidebar-logo" src="../../../_static/logo-redis.svg" alt="Logo"/>
  </div>
  
  <span class="sidebar-brand-text">redis-py 5.1.1 文档</span>
  
</a><form class="sidebar-search-container" method="get" action="../../../search.html" role="search">
  <input class="sidebar-search" placeholder="搜索" name="q" aria-label="搜索">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../genindex.html">索引</a></li>
</ul>
<ul>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../commands/index.html">Redis 命令</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle navigation of Redis 命令</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../commands/core.html">核心命令(Core Commands)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../commands/sentinel.html">哨兵命令(Sentinel Commands)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../commands/cluster.html">Redis 集群命令(Cluster Commands)</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../redismodules/index.html">Redis 模块命令(Modules Commands)</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><div class="visually-hidden">Toggle navigation of Redis 模块命令(Modules Commands)</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../redismodules/bloom.html">RedisBloom 命令</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../redismodules/graph.html">RedisGraph 命令</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../redismodules/json.html">RedisJSON 命令</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../redismodules/search.html">RediSearch 命令</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../redismodules/timeseries.html">RedisTimeSeries 命令</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../connections.html">连接到 Redis (Connecting to Redis)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../clustering.html">集群(Clustering)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../exceptions.html">异常(Exceptions)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../backoff.html">回退(Backoff)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../lock.html">锁(Lock)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../retry.html">重试工具(Retry Helpers)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../lua_scripting.html">Lua脚本(Lua Scripting)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../opentelemetry.html">集成 OpenTelemetry(Integrating)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../resp3_features.html">RESP 3 功能(RESP 3 Features)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../advanced_features.html">高级功能(Advanced Features)</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../examples.html">Examples</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" role="switch" type="checkbox"/><label for="toctree-checkbox-3"><div class="visually-hidden">Toggle navigation of Examples</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../examples/connection_examples.html">连接示例(Connection Examples)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../examples/ssl_connection_examples.html">SSL 连接示例</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../examples/asyncio_examples.html">异步示例(Asyncio Examples)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../examples/search_json_examples.html">索引 / 查询 JSON 文档</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../examples/set_and_get_examples.html"><code class="docutils literal notranslate"><span class="pre">set</span></code> 和 <code class="docutils literal notranslate"><span class="pre">get</span></code> 基本操作</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../examples/search_vector_similarity_examples.html">向量相似度(Vector Similarity)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../examples/pipeline_examples.html">管道示例</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../examples/timeseries_examples.html">时间序列(Timeseries)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../examples/redis-stream-example.html">Redis 流示例(Stream Examples)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../examples/redis-stream-example.html#流组(Stream-groups)">流组(Stream groups)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../examples/opentelemetry_api_examples.html">OpenTelemetry Python API</a></li>
</ul>
</li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
              <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon no-toc" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main" id="furo-main-content">
          <h1>redis.commands.core 源代码</h1><div class="highlight"><pre>
<span></span><span class="c1"># from __future__ import annotations</span>

<span class="kn">import</span> <span class="nn">datetime</span>
<span class="kn">import</span> <span class="nn">hashlib</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">TYPE_CHECKING</span><span class="p">,</span>
    <span class="n">AsyncIterator</span><span class="p">,</span>
    <span class="n">Awaitable</span><span class="p">,</span>
    <span class="n">Callable</span><span class="p">,</span>
    <span class="n">Dict</span><span class="p">,</span>
    <span class="n">Iterable</span><span class="p">,</span>
    <span class="n">Iterator</span><span class="p">,</span>
    <span class="n">List</span><span class="p">,</span>
    <span class="n">Literal</span><span class="p">,</span>
    <span class="n">Mapping</span><span class="p">,</span>
    <span class="n">Optional</span><span class="p">,</span>
    <span class="n">Sequence</span><span class="p">,</span>
    <span class="n">Set</span><span class="p">,</span>
    <span class="n">Tuple</span><span class="p">,</span>
    <span class="n">Union</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">from</span> <span class="nn">redis.exceptions</span> <span class="kn">import</span> <span class="ne">ConnectionError</span><span class="p">,</span> <span class="n">DataError</span><span class="p">,</span> <span class="n">NoScriptError</span><span class="p">,</span> <span class="n">RedisError</span>
<span class="kn">from</span> <span class="nn">redis.typing</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">AbsExpiryT</span><span class="p">,</span>
    <span class="n">AnyKeyT</span><span class="p">,</span>
    <span class="n">BitfieldOffsetT</span><span class="p">,</span>
    <span class="n">ChannelT</span><span class="p">,</span>
    <span class="n">CommandsProtocol</span><span class="p">,</span>
    <span class="n">ConsumerT</span><span class="p">,</span>
    <span class="n">EncodableT</span><span class="p">,</span>
    <span class="n">ExpiryT</span><span class="p">,</span>
    <span class="n">FieldT</span><span class="p">,</span>
    <span class="n">GroupT</span><span class="p">,</span>
    <span class="n">KeysT</span><span class="p">,</span>
    <span class="n">KeyT</span><span class="p">,</span>
    <span class="n">PatternT</span><span class="p">,</span>
    <span class="n">ResponseT</span><span class="p">,</span>
    <span class="n">ScriptTextT</span><span class="p">,</span>
    <span class="n">StreamIdT</span><span class="p">,</span>
    <span class="n">TimeoutSecT</span><span class="p">,</span>
    <span class="n">ZScoreBoundT</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">from</span> <span class="nn">.helpers</span> <span class="kn">import</span> <span class="n">list_or_args</span>

<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">redis.asyncio.client</span>
    <span class="kn">import</span> <span class="nn">redis.client</span>


<span class="k">class</span> <span class="nc">ACLCommands</span><span class="p">(</span><span class="n">CommandsProtocol</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Redis Access Control List (ACL) commands.</span>
<span class="sd">    see: https://redis.io/topics/acl</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">acl_cat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">category</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a list of categories or commands within a category.</span>

<span class="sd">        If ``category`` is not supplied, returns a list of all categories.</span>
<span class="sd">        If ``category`` is supplied, returns a list of all commands within</span>
<span class="sd">        that category.</span>

<span class="sd">        For more information see https://redis.io/commands/acl-cat</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pieces</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">EncodableT</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">category</span><span class="p">]</span> <span class="k">if</span> <span class="n">category</span> <span class="k">else</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;ACL CAT&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">pieces</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">acl_dryrun</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">username</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simulate the execution of a given command by a given ``username``.</span>

<span class="sd">        For more information see https://redis.io/commands/acl-dryrun</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;ACL DRYRUN&quot;</span><span class="p">,</span> <span class="n">username</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">acl_deluser</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">username</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Delete the ACL for the specified ``username``\\s</span>

<span class="sd">        For more information see https://redis.io/commands/acl-deluser</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;ACL DELUSER&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">username</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">acl_genpass</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bits</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate a random password value.</span>
<span class="sd">        If ``bits`` is supplied then use this number of bits, rounded to</span>
<span class="sd">        the next multiple of 4.</span>
<span class="sd">        See: https://redis.io/commands/acl-genpass</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pieces</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">bits</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">b</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">bits</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">b</span> <span class="o">&gt;</span> <span class="mi">4096</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span>
                <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span>
                    <span class="s2">&quot;genpass optionally accepts a bits argument, between 0 and 4096.&quot;</span>
                <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;ACL GENPASS&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">pieces</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">acl_getuser</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">username</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the ACL details for the specified ``username``.</span>

<span class="sd">        If ``username`` does not exist, return None</span>

<span class="sd">        For more information see https://redis.io/commands/acl-getuser</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;ACL GETUSER&quot;</span><span class="p">,</span> <span class="n">username</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">acl_help</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The ACL HELP command returns helpful text describing</span>
<span class="sd">        the different subcommands.</span>

<span class="sd">        For more information see https://redis.io/commands/acl-help</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;ACL HELP&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">acl_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list of all ACLs on the server</span>

<span class="sd">        For more information see https://redis.io/commands/acl-list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;ACL LIST&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">acl_log</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">count</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get ACL logs as a list.</span>
<span class="sd">        :param int count: Get logs[0:count].</span>
<span class="sd">        :rtype: List.</span>

<span class="sd">        For more information see https://redis.io/commands/acl-log</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">count</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span><span class="s2">&quot;ACL LOG count must be an integer&quot;</span><span class="p">)</span>
            <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">count</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;ACL LOG&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">acl_log_reset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reset ACL logs.</span>
<span class="sd">        :rtype: Boolean.</span>

<span class="sd">        For more information see https://redis.io/commands/acl-log</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="sa">b</span><span class="s2">&quot;RESET&quot;</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;ACL LOG&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">acl_load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load ACL rules from the configured ``aclfile``.</span>

<span class="sd">        Note that the server must be configured with the ``aclfile``</span>
<span class="sd">        directive to be able to load ACL rules from an aclfile.</span>

<span class="sd">        For more information see https://redis.io/commands/acl-load</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;ACL LOAD&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">acl_save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save ACL rules to the configured ``aclfile``.</span>

<span class="sd">        Note that the server must be configured with the ``aclfile``</span>
<span class="sd">        directive to be able to save ACL rules to an aclfile.</span>

<span class="sd">        For more information see https://redis.io/commands/acl-save</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;ACL SAVE&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">acl_setuser</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">username</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">enabled</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">nopass</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">passwords</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">hashed_passwords</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">categories</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">commands</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">keys</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="n">KeyT</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">channels</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="n">ChannelT</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">selectors</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">KeyT</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">reset</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">reset_keys</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">reset_channels</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">reset_passwords</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create or update an ACL user.</span>

<span class="sd">        Create or update the ACL for `username`. If the user already exists,</span>
<span class="sd">        the existing ACL is completely overwritten and replaced with the</span>
<span class="sd">        specified values.</span>

<span class="sd">        For more information, see https://redis.io/commands/acl-setuser</span>

<span class="sd">        Args:</span>
<span class="sd">            username: The name of the user whose ACL is to be created or updated.</span>
<span class="sd">            enabled: Indicates whether the user should be allowed to authenticate.</span>
<span class="sd">                     Defaults to `False`.</span>
<span class="sd">            nopass: Indicates whether the user can authenticate without a password.</span>
<span class="sd">                    This cannot be `True` if `passwords` are also specified.</span>
<span class="sd">            passwords: A list of plain text passwords to add to or remove from the user.</span>
<span class="sd">                       Each password must be prefixed with a &#39;+&#39; to add or a &#39;-&#39; to</span>
<span class="sd">                       remove. For convenience, a single prefixed string can be used</span>
<span class="sd">                       when adding or removing a single password.</span>
<span class="sd">            hashed_passwords: A list of SHA-256 hashed passwords to add to or remove</span>
<span class="sd">                              from the user. Each hashed password must be prefixed with</span>
<span class="sd">                              a &#39;+&#39; to add or a &#39;-&#39; to remove. For convenience, a single</span>
<span class="sd">                              prefixed string can be used when adding or removing a</span>
<span class="sd">                              single password.</span>
<span class="sd">            categories: A list of strings representing category permissions. Each string</span>
<span class="sd">                        must be prefixed with either a &#39;+&#39; to add the category</span>
<span class="sd">                        permission or a &#39;-&#39; to remove the category permission.</span>
<span class="sd">            commands: A list of strings representing command permissions. Each string</span>
<span class="sd">                      must be prefixed with either a &#39;+&#39; to add the command permission</span>
<span class="sd">                      or a &#39;-&#39; to remove the command permission.</span>
<span class="sd">            keys: A list of key patterns to grant the user access to. Key patterns allow</span>
<span class="sd">                  ``&#39;*&#39;`` to support wildcard matching. For example, ``&#39;*&#39;`` grants</span>
<span class="sd">                  access to all keys while ``&#39;cache:*&#39;`` grants access to all keys that</span>
<span class="sd">                  are prefixed with ``cache:``.</span>
<span class="sd">                  `keys` should not be prefixed with a ``&#39;~&#39;``.</span>
<span class="sd">            reset: Indicates whether the user should be fully reset prior to applying</span>
<span class="sd">                   the new ACL. Setting this to `True` will remove all existing</span>
<span class="sd">                   passwords, flags, and privileges from the user and then apply the</span>
<span class="sd">                   specified rules. If `False`, the user&#39;s existing passwords, flags,</span>
<span class="sd">                   and privileges will be kept and any new specified rules will be</span>
<span class="sd">                   applied on top.</span>
<span class="sd">            reset_keys: Indicates whether the user&#39;s key permissions should be reset</span>
<span class="sd">                        prior to applying any new key permissions specified in `keys`.</span>
<span class="sd">                        If `False`, the user&#39;s existing key permissions will be kept and</span>
<span class="sd">                        any new specified key permissions will be applied on top.</span>
<span class="sd">            reset_channels: Indicates whether the user&#39;s channel permissions should be</span>
<span class="sd">                            reset prior to applying any new channel permissions</span>
<span class="sd">                            specified in `channels`. If `False`, the user&#39;s existing</span>
<span class="sd">                            channel permissions will be kept and any new specified</span>
<span class="sd">                            channel permissions will be applied on top.</span>
<span class="sd">            reset_passwords: Indicates whether to remove all existing passwords and the</span>
<span class="sd">                             `nopass` flag from the user prior to applying any new</span>
<span class="sd">                             passwords specified in `passwords` or `hashed_passwords`.</span>
<span class="sd">                             If `False`, the user&#39;s existing passwords and `nopass`</span>
<span class="sd">                             status will be kept and any new specified passwords or</span>
<span class="sd">                             hashed passwords will be applied on top.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">encoder</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_encoder</span><span class="p">()</span>
        <span class="n">pieces</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">EncodableT</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">username</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">reset</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;reset&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">reset_keys</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;resetkeys&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">reset_channels</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;resetchannels&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">reset_passwords</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;resetpass&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">enabled</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;on&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;off&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">passwords</span> <span class="ow">or</span> <span class="n">hashed_passwords</span><span class="p">)</span> <span class="ow">and</span> <span class="n">nopass</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot set &#39;nopass&#39; and supply &#39;passwords&#39; or &#39;hashed_passwords&#39;&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">passwords</span><span class="p">:</span>
            <span class="c1"># as most users will have only one password, allow remove_passwords</span>
            <span class="c1"># to be specified as a simple string or a list</span>
            <span class="n">passwords</span> <span class="o">=</span> <span class="n">list_or_args</span><span class="p">(</span><span class="n">passwords</span><span class="p">,</span> <span class="p">[])</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">password</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">passwords</span><span class="p">):</span>
                <span class="n">password</span> <span class="o">=</span> <span class="n">encoder</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">password</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">password</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;+&quot;</span><span class="p">):</span>
                    <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;&gt;</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">password</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
                <span class="k">elif</span> <span class="n">password</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;-&quot;</span><span class="p">):</span>
                    <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;&lt;</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">password</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Password </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> must be prefixed with a &quot;</span>
                        <span class="sa">f</span><span class="s1">&#39;&quot;+&quot; to add or a &quot;-&quot; to remove&#39;</span>
                    <span class="p">)</span>

        <span class="k">if</span> <span class="n">hashed_passwords</span><span class="p">:</span>
            <span class="c1"># as most users will have only one password, allow remove_passwords</span>
            <span class="c1"># to be specified as a simple string or a list</span>
            <span class="n">hashed_passwords</span> <span class="o">=</span> <span class="n">list_or_args</span><span class="p">(</span><span class="n">hashed_passwords</span><span class="p">,</span> <span class="p">[])</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">hashed_password</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">hashed_passwords</span><span class="p">):</span>
                <span class="n">hashed_password</span> <span class="o">=</span> <span class="n">encoder</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">hashed_password</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">hashed_password</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;+&quot;</span><span class="p">):</span>
                    <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;#</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">hashed_password</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
                <span class="k">elif</span> <span class="n">hashed_password</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;-&quot;</span><span class="p">):</span>
                    <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;!</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">hashed_password</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Hashed password </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> must be prefixed with a &quot;</span>
                        <span class="sa">f</span><span class="s1">&#39;&quot;+&quot; to add or a &quot;-&quot; to remove&#39;</span>
                    <span class="p">)</span>

        <span class="k">if</span> <span class="n">nopass</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;nopass&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">categories</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">category</span> <span class="ow">in</span> <span class="n">categories</span><span class="p">:</span>
                <span class="n">category</span> <span class="o">=</span> <span class="n">encoder</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">category</span><span class="p">)</span>
                <span class="c1"># categories can be prefixed with one of (+@, +, -@, -)</span>
                <span class="k">if</span> <span class="n">category</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;+@&quot;</span><span class="p">):</span>
                    <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">category</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">category</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;+&quot;</span><span class="p">):</span>
                    <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;+@</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">category</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
                <span class="k">elif</span> <span class="n">category</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;-@&quot;</span><span class="p">):</span>
                    <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">category</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">category</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;-&quot;</span><span class="p">):</span>
                    <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;-@</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">category</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s1">&#39;Category &quot;</span><span class="si">{</span><span class="n">encoder</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="n">category</span><span class="p">,</span><span class="w"> </span><span class="n">force</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="si">}</span><span class="s1">&quot; &#39;</span>
                        <span class="s1">&#39;must be prefixed with &quot;+&quot; or &quot;-&quot;&#39;</span>
                    <span class="p">)</span>
        <span class="k">if</span> <span class="n">commands</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">cmd</span> <span class="ow">in</span> <span class="n">commands</span><span class="p">:</span>
                <span class="n">cmd</span> <span class="o">=</span> <span class="n">encoder</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">cmd</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;+&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">cmd</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;-&quot;</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s1">&#39;Command &quot;</span><span class="si">{</span><span class="n">encoder</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span><span class="w"> </span><span class="n">force</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="si">}</span><span class="s1">&quot; &#39;</span>
                        <span class="s1">&#39;must be prefixed with &quot;+&quot; or &quot;-&quot;&#39;</span>
                    <span class="p">)</span>
                <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">keys</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
                <span class="n">key</span> <span class="o">=</span> <span class="n">encoder</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">key</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;%&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">key</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;~&quot;</span><span class="p">):</span>
                    <span class="n">key</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">&quot;~</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">key</span>
                <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">channels</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="n">channels</span><span class="p">:</span>
                <span class="n">channel</span> <span class="o">=</span> <span class="n">encoder</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span>
                <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;&amp;</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">channel</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">selectors</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">selectors</span><span class="p">:</span>
                <span class="n">cmd</span> <span class="o">=</span> <span class="n">encoder</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">cmd</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;+&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">cmd</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;-&quot;</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s1">&#39;Command &quot;</span><span class="si">{</span><span class="n">encoder</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span><span class="w"> </span><span class="n">force</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="si">}</span><span class="s1">&quot; &#39;</span>
                        <span class="s1">&#39;must be prefixed with &quot;+&quot; or &quot;-&quot;&#39;</span>
                    <span class="p">)</span>

                <span class="n">key</span> <span class="o">=</span> <span class="n">encoder</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">key</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;%&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">key</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;~&quot;</span><span class="p">):</span>
                    <span class="n">key</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">&quot;~</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">key</span>

                <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;(</span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">key</span><span class="p">))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;ACL SETUSER&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">pieces</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">acl_users</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a list of all registered users on the server.</span>

<span class="sd">        For more information see https://redis.io/commands/acl-users</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;ACL USERS&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">acl_whoami</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the username for the current connection</span>

<span class="sd">        For more information see https://redis.io/commands/acl-whoami</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;ACL WHOAMI&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="n">AsyncACLCommands</span> <span class="o">=</span> <span class="n">ACLCommands</span>


<span class="k">class</span> <span class="nc">ManagementCommands</span><span class="p">(</span><span class="n">CommandsProtocol</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Redis management commands</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">auth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">password</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">username</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Authenticates the user. If you do not pass username, Redis will try to</span>
<span class="sd">        authenticate for the &quot;default&quot; user. If you do pass username, it will</span>
<span class="sd">        authenticate for the given user.</span>
<span class="sd">        For more information see https://redis.io/commands/auth</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pieces</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">username</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">username</span><span class="p">)</span>
        <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">password</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;AUTH&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">pieces</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">bgrewriteaof</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Tell the Redis server to rewrite the AOF file from data in memory.</span>

<span class="sd">        For more information see https://redis.io/commands/bgrewriteaof</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;BGREWRITEAOF&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">bgsave</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">schedule</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Tell the Redis server to save its data to disk.  Unlike save(),</span>
<span class="sd">        this method is asynchronous and returns immediately.</span>

<span class="sd">        For more information see https://redis.io/commands/bgsave</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pieces</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">schedule</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;SCHEDULE&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;BGSAVE&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">pieces</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">role</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Provide information on the role of a Redis instance in</span>
<span class="sd">        the context of replication, by returning if the instance</span>
<span class="sd">        is currently a master, slave, or sentinel.</span>

<span class="sd">        For more information see https://redis.io/commands/role</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;ROLE&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">client_kill</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">address</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Disconnects the client at ``address`` (ip:port)</span>

<span class="sd">        For more information see https://redis.io/commands/client-kill</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;CLIENT KILL&quot;</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">client_kill_filter</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">_id</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">_type</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">addr</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">skipme</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">laddr</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">user</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">maxage</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Disconnects client(s) using a variety of filter options</span>
<span class="sd">        :param _id: Kills a client by its unique ID field</span>
<span class="sd">        :param _type: Kills a client by type where type is one of &#39;normal&#39;,</span>
<span class="sd">        &#39;master&#39;, &#39;slave&#39; or &#39;pubsub&#39;</span>
<span class="sd">        :param addr: Kills a client by its &#39;address:port&#39;</span>
<span class="sd">        :param skipme: If True, then the client calling the command</span>
<span class="sd">        will not get killed even if it is identified by one of the filter</span>
<span class="sd">        options. If skipme is not provided, the server defaults to skipme=True</span>
<span class="sd">        :param laddr: Kills a client by its &#39;local (bind) address:port&#39;</span>
<span class="sd">        :param user: Kills a client for a specific user name</span>
<span class="sd">        :param maxage: Kills clients that are older than the specified age in seconds</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">client_types</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;normal&quot;</span><span class="p">,</span> <span class="s2">&quot;master&quot;</span><span class="p">,</span> <span class="s2">&quot;slave&quot;</span><span class="p">,</span> <span class="s2">&quot;pubsub&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">_type</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">client_types</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;CLIENT KILL type must be one of </span><span class="si">{</span><span class="n">client_types</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">args</span><span class="o">.</span><span class="n">extend</span><span class="p">((</span><span class="sa">b</span><span class="s2">&quot;TYPE&quot;</span><span class="p">,</span> <span class="n">_type</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">skipme</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">skipme</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span><span class="s2">&quot;CLIENT KILL skipme must be a bool&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">skipme</span><span class="p">:</span>
                <span class="n">args</span><span class="o">.</span><span class="n">extend</span><span class="p">((</span><span class="sa">b</span><span class="s2">&quot;SKIPME&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;YES&quot;</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">args</span><span class="o">.</span><span class="n">extend</span><span class="p">((</span><span class="sa">b</span><span class="s2">&quot;SKIPME&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;NO&quot;</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">args</span><span class="o">.</span><span class="n">extend</span><span class="p">((</span><span class="sa">b</span><span class="s2">&quot;ID&quot;</span><span class="p">,</span> <span class="n">_id</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">addr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">args</span><span class="o">.</span><span class="n">extend</span><span class="p">((</span><span class="sa">b</span><span class="s2">&quot;ADDR&quot;</span><span class="p">,</span> <span class="n">addr</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">laddr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">args</span><span class="o">.</span><span class="n">extend</span><span class="p">((</span><span class="sa">b</span><span class="s2">&quot;LADDR&quot;</span><span class="p">,</span> <span class="n">laddr</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">user</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">args</span><span class="o">.</span><span class="n">extend</span><span class="p">((</span><span class="sa">b</span><span class="s2">&quot;USER&quot;</span><span class="p">,</span> <span class="n">user</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">maxage</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">args</span><span class="o">.</span><span class="n">extend</span><span class="p">((</span><span class="sa">b</span><span class="s2">&quot;MAXAGE&quot;</span><span class="p">,</span> <span class="n">maxage</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">args</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span>
                <span class="s2">&quot;CLIENT KILL &lt;filter&gt; &lt;value&gt; ... ... &lt;filter&gt; &quot;</span>
                <span class="s2">&quot;&lt;value&gt; must specify at least one filter&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;CLIENT KILL&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">client_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns information and statistics about the current</span>
<span class="sd">        client connection.</span>

<span class="sd">        For more information see https://redis.io/commands/client-info</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;CLIENT INFO&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">client_list</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">_type</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">client_id</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">EncodableT</span><span class="p">]</span> <span class="o">=</span> <span class="p">[],</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a list of currently connected clients.</span>
<span class="sd">        If type of client specified, only that type will be returned.</span>

<span class="sd">        :param _type: optional. one of the client types (normal, master,</span>
<span class="sd">         replica, pubsub)</span>
<span class="sd">        :param client_id: optional. a list of client ids</span>

<span class="sd">        For more information see https://redis.io/commands/client-list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">client_types</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;normal&quot;</span><span class="p">,</span> <span class="s2">&quot;master&quot;</span><span class="p">,</span> <span class="s2">&quot;replica&quot;</span><span class="p">,</span> <span class="s2">&quot;pubsub&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">_type</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">client_types</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;CLIENT LIST _type must be one of </span><span class="si">{</span><span class="n">client_types</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;TYPE&quot;</span><span class="p">)</span>
            <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_type</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">client_id</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span><span class="s2">&quot;client_id must be a list&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">client_id</span><span class="p">:</span>
            <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;ID&quot;</span><span class="p">)</span>
            <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">client_id</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;CLIENT LIST&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">client_getname</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the current connection name</span>

<span class="sd">        For more information see https://redis.io/commands/client-getname</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;CLIENT GETNAME&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">client_getredir</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the ID (an integer) of the client to whom we are</span>
<span class="sd">        redirecting tracking notifications.</span>

<span class="sd">        see: https://redis.io/commands/client-getredir</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;CLIENT GETREDIR&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">client_reply</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">reply</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;ON&quot;</span><span class="p">],</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;OFF&quot;</span><span class="p">],</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;SKIP&quot;</span><span class="p">]],</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Enable and disable redis server replies.</span>

<span class="sd">        ``reply`` Must be ON OFF or SKIP,</span>
<span class="sd">        ON - The default most with server replies to commands</span>
<span class="sd">        OFF - Disable server responses to commands</span>
<span class="sd">        SKIP - Skip the response of the immediately following command.</span>

<span class="sd">        Note: When setting OFF or SKIP replies, you will need a client object</span>
<span class="sd">        with a timeout specified in seconds, and will need to catch the</span>
<span class="sd">        TimeoutError.</span>
<span class="sd">        The test_client_reply unit test illustrates this, and</span>
<span class="sd">        conftest.py has a client with a timeout.</span>

<span class="sd">        See https://redis.io/commands/client-reply</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">replies</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;ON&quot;</span><span class="p">,</span> <span class="s2">&quot;OFF&quot;</span><span class="p">,</span> <span class="s2">&quot;SKIP&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">reply</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">replies</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;CLIENT REPLY must be one of </span><span class="si">{</span><span class="n">replies</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;CLIENT REPLY&quot;</span><span class="p">,</span> <span class="n">reply</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">client_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the current connection id</span>

<span class="sd">        For more information see https://redis.io/commands/client-id</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;CLIENT ID&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">client_tracking_on</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">clientid</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">prefix</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">KeyT</span><span class="p">]</span> <span class="o">=</span> <span class="p">[],</span>
        <span class="n">bcast</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">optin</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">optout</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">noloop</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Turn on the tracking mode.</span>
<span class="sd">        For more information about the options look at client_tracking func.</span>

<span class="sd">        See https://redis.io/commands/client-tracking</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">client_tracking</span><span class="p">(</span>
            <span class="kc">True</span><span class="p">,</span> <span class="n">clientid</span><span class="p">,</span> <span class="n">prefix</span><span class="p">,</span> <span class="n">bcast</span><span class="p">,</span> <span class="n">optin</span><span class="p">,</span> <span class="n">optout</span><span class="p">,</span> <span class="n">noloop</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">client_tracking_off</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">clientid</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">prefix</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">KeyT</span><span class="p">]</span> <span class="o">=</span> <span class="p">[],</span>
        <span class="n">bcast</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">optin</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">optout</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">noloop</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Turn off the tracking mode.</span>
<span class="sd">        For more information about the options look at client_tracking func.</span>

<span class="sd">        See https://redis.io/commands/client-tracking</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">client_tracking</span><span class="p">(</span>
            <span class="kc">False</span><span class="p">,</span> <span class="n">clientid</span><span class="p">,</span> <span class="n">prefix</span><span class="p">,</span> <span class="n">bcast</span><span class="p">,</span> <span class="n">optin</span><span class="p">,</span> <span class="n">optout</span><span class="p">,</span> <span class="n">noloop</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">client_tracking</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">on</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">clientid</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">prefix</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">KeyT</span><span class="p">]</span> <span class="o">=</span> <span class="p">[],</span>
        <span class="n">bcast</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">optin</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">optout</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">noloop</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Enables the tracking feature of the Redis server, that is used</span>
<span class="sd">        for server assisted client side caching.</span>

<span class="sd">        ``on`` indicate for tracking on or tracking off. The dafualt is on.</span>

<span class="sd">        ``clientid`` send invalidation messages to the connection with</span>
<span class="sd">        the specified ID.</span>

<span class="sd">        ``bcast`` enable tracking in broadcasting mode. In this mode</span>
<span class="sd">        invalidation messages are reported for all the prefixes</span>
<span class="sd">        specified, regardless of the keys requested by the connection.</span>

<span class="sd">        ``optin``  when broadcasting is NOT active, normally don&#39;t track</span>
<span class="sd">        keys in read only commands, unless they are called immediately</span>
<span class="sd">        after a CLIENT CACHING yes command.</span>

<span class="sd">        ``optout`` when broadcasting is NOT active, normally track keys in</span>
<span class="sd">        read only commands, unless they are called immediately after a</span>
<span class="sd">        CLIENT CACHING no command.</span>

<span class="sd">        ``noloop`` don&#39;t send notifications about keys modified by this</span>
<span class="sd">        connection itself.</span>

<span class="sd">        ``prefix``  for broadcasting, register a given key prefix, so that</span>
<span class="sd">        notifications will be provided only for keys starting with this string.</span>

<span class="sd">        See https://redis.io/commands/client-tracking</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">bcast</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span><span class="s2">&quot;Prefix can only be used with bcast&quot;</span><span class="p">)</span>

        <span class="n">pieces</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;ON&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="n">on</span> <span class="k">else</span> <span class="p">[</span><span class="s2">&quot;OFF&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">clientid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s2">&quot;REDIRECT&quot;</span><span class="p">,</span> <span class="n">clientid</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">prefix</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s2">&quot;PREFIX&quot;</span><span class="p">,</span> <span class="n">p</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">bcast</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;BCAST&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">optin</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;OPTIN&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">optout</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;OPTOUT&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">noloop</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;NOLOOP&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;CLIENT TRACKING&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">pieces</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">client_trackinginfo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the information about the current client connection&#39;s</span>
<span class="sd">        use of the server assisted client side cache.</span>

<span class="sd">        See https://redis.io/commands/client-trackinginfo</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;CLIENT TRACKINGINFO&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">client_setname</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the current connection name</span>

<span class="sd">        For more information see https://redis.io/commands/client-setname</span>

<span class="sd">        .. note::</span>
<span class="sd">           This method sets client name only for **current** connection.</span>

<span class="sd">           If you want to set a common name for all connections managed</span>
<span class="sd">           by this client, use ``client_name`` constructor argument.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;CLIENT SETNAME&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">client_setinfo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the current connection library name or version</span>
<span class="sd">        For mor information see https://redis.io/commands/client-setinfo</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;CLIENT SETINFO&quot;</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">client_unblock</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">client_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">error</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Unblocks a connection by its client id.</span>
<span class="sd">        If ``error`` is True, unblocks the client with a special error message.</span>
<span class="sd">        If ``error`` is False (default), the client is unblocked using the</span>
<span class="sd">        regular timeout mechanism.</span>

<span class="sd">        For more information see https://redis.io/commands/client-unblock</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;CLIENT UNBLOCK&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">client_id</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">error</span><span class="p">:</span>
            <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;ERROR&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">client_pause</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeout</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">all</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Suspend all the Redis clients for the specified amount of time.</span>


<span class="sd">        For more information see https://redis.io/commands/client-pause</span>

<span class="sd">        Args:</span>
<span class="sd">            timeout: milliseconds to pause clients</span>
<span class="sd">            all: If true (default) all client commands are blocked.</span>
<span class="sd">                 otherwise, clients are only blocked if they attempt to execute</span>
<span class="sd">                 a write command.</span>

<span class="sd">        For the WRITE mode, some commands have special behavior:</span>

<span class="sd">        * EVAL/EVALSHA: Will block client for all scripts.</span>
<span class="sd">        * PUBLISH: Will block client.</span>
<span class="sd">        * PFCOUNT: Will block client.</span>
<span class="sd">        * WAIT: Acknowledgments will be delayed, so this command will</span>
<span class="sd">            appear blocked.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;CLIENT PAUSE&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">timeout</span><span class="p">)]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">timeout</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span><span class="s2">&quot;CLIENT PAUSE timeout must be an integer&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">:</span>
            <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;WRITE&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">client_unpause</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Unpause all redis clients</span>

<span class="sd">        For more information see https://redis.io/commands/client-unpause</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;CLIENT UNPAUSE&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">client_no_evict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Awaitable</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the client eviction mode for the current connection.</span>

<span class="sd">        For more information see https://redis.io/commands/client-no-evict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;CLIENT NO-EVICT&quot;</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">client_no_touch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Awaitable</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        # The command controls whether commands sent by the client will alter</span>
<span class="sd">        # the LRU/LFU of the keys they access.</span>
<span class="sd">        # When turned on, the current client will not change LFU/LRU stats,</span>
<span class="sd">        # unless it sends the TOUCH command.</span>

<span class="sd">        For more information see https://redis.io/commands/client-no-touch</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;CLIENT NO-TOUCH&quot;</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">command</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns dict reply of details about all Redis commands.</span>

<span class="sd">        For more information see https://redis.io/commands/command</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;COMMAND&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">command_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;COMMAND INFO is intentionally not implemented in the client.&quot;</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">command_count</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;COMMAND COUNT&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">command_list</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">module</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">category</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">pattern</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an array of the server&#39;s command names.</span>
<span class="sd">        You can use one of the following filters:</span>
<span class="sd">        ``module``: get the commands that belong to the module</span>
<span class="sd">        ``category``: get the commands in the ACL category</span>
<span class="sd">        ``pattern``: get the commands that match the given pattern</span>

<span class="sd">        For more information see https://redis.io/commands/command-list/</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pieces</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">module</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s2">&quot;MODULE&quot;</span><span class="p">,</span> <span class="n">module</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">category</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s2">&quot;ACLCAT&quot;</span><span class="p">,</span> <span class="n">category</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">pattern</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s2">&quot;PATTERN&quot;</span><span class="p">,</span> <span class="n">pattern</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">pieces</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;FILTERBY&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;COMMAND LIST&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">pieces</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">command_getkeysandflags</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns array of keys from a full Redis command and their usage flags.</span>

<span class="sd">        For more information see https://redis.io/commands/command-getkeysandflags</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;COMMAND GETKEYSANDFLAGS&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">command_docs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function throws a NotImplementedError since it is intentionally</span>
<span class="sd">        not supported.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;COMMAND DOCS is intentionally not implemented in the client.&quot;</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">config_get</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">pattern</span><span class="p">:</span> <span class="n">PatternT</span> <span class="o">=</span> <span class="s2">&quot;*&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">PatternT</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a dictionary of configuration based on the ``pattern``</span>

<span class="sd">        For more information see https://redis.io/commands/config-get</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;CONFIG GET&quot;</span><span class="p">,</span> <span class="n">pattern</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">config_set</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span>
        <span class="n">value</span><span class="p">:</span> <span class="n">EncodableT</span><span class="p">,</span>
        <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">KeyT</span><span class="p">,</span> <span class="n">EncodableT</span><span class="p">]],</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set config item ``name`` with ``value``</span>

<span class="sd">        For more information see https://redis.io/commands/config-set</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;CONFIG SET&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">config_resetstat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reset runtime statistics</span>

<span class="sd">        For more information see https://redis.io/commands/config-resetstat</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;CONFIG RESETSTAT&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">config_rewrite</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rewrite config file with the minimal change to reflect running config.</span>

<span class="sd">        For more information see https://redis.io/commands/config-rewrite</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;CONFIG REWRITE&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">dbsize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of keys in the current database</span>

<span class="sd">        For more information see https://redis.io/commands/dbsize</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;DBSIZE&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">debug_object</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns version specific meta information about a given key</span>

<span class="sd">        For more information see https://redis.io/commands/debug-object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;DEBUG OBJECT&quot;</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">debug_segfault</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            DEBUG SEGFAULT is intentionally not implemented in the client.</span>

<span class="sd">            For more information see https://redis.io/commands/debug-segfault</span>
<span class="sd">            &quot;&quot;&quot;</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">echo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">EncodableT</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Echo the string back from the server</span>

<span class="sd">        For more information see https://redis.io/commands/echo</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;ECHO&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">flushall</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">asynchronous</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Delete all keys in all databases on the current host.</span>

<span class="sd">        ``asynchronous`` indicates whether the operation is</span>
<span class="sd">        executed asynchronously by the server.</span>

<span class="sd">        For more information see https://redis.io/commands/flushall</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">asynchronous</span><span class="p">:</span>
            <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;ASYNC&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;FLUSHALL&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">flushdb</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">asynchronous</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Delete all keys in the current database.</span>

<span class="sd">        ``asynchronous`` indicates whether the operation is</span>
<span class="sd">        executed asynchronously by the server.</span>

<span class="sd">        For more information see https://redis.io/commands/flushdb</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">asynchronous</span><span class="p">:</span>
            <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;ASYNC&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;FLUSHDB&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">sync</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initiates a replication stream from the master.</span>

<span class="sd">        For more information see https://redis.io/commands/sync</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">redis.client</span> <span class="kn">import</span> <span class="n">NEVER_DECODE</span>

        <span class="n">options</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">options</span><span class="p">[</span><span class="n">NEVER_DECODE</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;SYNC&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">psync</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">replicationid</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">offset</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initiates a replication stream from the master.</span>
<span class="sd">        Newer version for `sync`.</span>

<span class="sd">        For more information see https://redis.io/commands/sync</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">redis.client</span> <span class="kn">import</span> <span class="n">NEVER_DECODE</span>

        <span class="n">options</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">options</span><span class="p">[</span><span class="n">NEVER_DECODE</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;PSYNC&quot;</span><span class="p">,</span> <span class="n">replicationid</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">swapdb</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">first</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">second</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Swap two databases</span>

<span class="sd">        For more information see https://redis.io/commands/swapdb</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;SWAPDB&quot;</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">second</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">select</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Select the Redis logical database at index.</span>

<span class="sd">        See: https://redis.io/commands/select</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;SELECT&quot;</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">info</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">section</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a dictionary containing information about the Redis server</span>

<span class="sd">        The ``section`` option can be used to select a specific section</span>
<span class="sd">        of information</span>

<span class="sd">        The section option is not supported by older versions of Redis Server,</span>
<span class="sd">        and will generate ResponseError</span>

<span class="sd">        For more information see https://redis.io/commands/info</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">section</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;INFO&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;INFO&quot;</span><span class="p">,</span> <span class="n">section</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">lastsave</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a Python datetime object representing the last time the</span>
<span class="sd">        Redis database was saved to disk</span>

<span class="sd">        For more information see https://redis.io/commands/lastsave</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;LASTSAVE&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">latency_doctor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Raise a NotImplementedError, as the client will not support LATENCY DOCTOR.</span>
<span class="sd">        This funcion is best used within the redis-cli.</span>

<span class="sd">        For more information see https://redis.io/commands/latency-doctor</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            LATENCY DOCTOR is intentionally not implemented in the client.</span>

<span class="sd">            For more information see https://redis.io/commands/latency-doctor</span>
<span class="sd">            &quot;&quot;&quot;</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">latency_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Raise a NotImplementedError, as the client will not support LATENCY GRAPH.</span>
<span class="sd">        This funcion is best used within the redis-cli.</span>

<span class="sd">        For more information see https://redis.io/commands/latency-graph.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            LATENCY GRAPH is intentionally not implemented in the client.</span>

<span class="sd">            For more information see https://redis.io/commands/latency-graph</span>
<span class="sd">            &quot;&quot;&quot;</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">lolwut</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">version_numbers</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the Redis version and a piece of generative computer art</span>

<span class="sd">        See: https://redis.io/commands/lolwut</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">version_numbers</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;LOLWUT VERSION&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">version_numbers</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;LOLWUT&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Perform a full reset on the connection&#39;s server side contenxt.</span>

<span class="sd">        See: https://redis.io/commands/reset</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;RESET&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">migrate</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">host</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">port</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">keys</span><span class="p">:</span> <span class="n">KeysT</span><span class="p">,</span>
        <span class="n">destination_db</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">timeout</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">replace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">auth</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Migrate 1 or more keys from the current Redis server to a different</span>
<span class="sd">        server specified by the ``host``, ``port`` and ``destination_db``.</span>

<span class="sd">        The ``timeout``, specified in milliseconds, indicates the maximum</span>
<span class="sd">        time the connection between the two servers can be idle before the</span>
<span class="sd">        command is interrupted.</span>

<span class="sd">        If ``copy`` is True, the specified ``keys`` are NOT deleted from</span>
<span class="sd">        the source server.</span>

<span class="sd">        If ``replace`` is True, this operation will overwrite the keys</span>
<span class="sd">        on the destination server if they exist.</span>

<span class="sd">        If ``auth`` is specified, authenticate to the destination server with</span>
<span class="sd">        the password provided.</span>

<span class="sd">        For more information see https://redis.io/commands/migrate</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="n">list_or_args</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="p">[])</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">keys</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span><span class="s2">&quot;MIGRATE requires at least one key&quot;</span><span class="p">)</span>
        <span class="n">pieces</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;COPY&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">replace</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;REPLACE&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">auth</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;AUTH&quot;</span><span class="p">)</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">auth</span><span class="p">)</span>
        <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;KEYS&quot;</span><span class="p">)</span>
        <span class="n">pieces</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span>
            <span class="s2">&quot;MIGRATE&quot;</span><span class="p">,</span> <span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">destination_db</span><span class="p">,</span> <span class="n">timeout</span><span class="p">,</span> <span class="o">*</span><span class="n">pieces</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">object</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">infotype</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the encoding, idletime, or refcount about the key</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span>
            <span class="s2">&quot;OBJECT&quot;</span><span class="p">,</span> <span class="n">infotype</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">infotype</span><span class="o">=</span><span class="n">infotype</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">memory_doctor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            MEMORY DOCTOR is intentionally not implemented in the client.</span>

<span class="sd">            For more information see https://redis.io/commands/memory-doctor</span>
<span class="sd">            &quot;&quot;&quot;</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">memory_help</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            MEMORY HELP is intentionally not implemented in the client.</span>

<span class="sd">            For more information see https://redis.io/commands/memory-help</span>
<span class="sd">            &quot;&quot;&quot;</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">memory_stats</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a dictionary of memory stats</span>

<span class="sd">        For more information see https://redis.io/commands/memory-stats</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;MEMORY STATS&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">memory_malloc_stats</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an internal statistics report from the memory allocator.</span>

<span class="sd">        See: https://redis.io/commands/memory-malloc-stats</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;MEMORY MALLOC-STATS&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">memory_usage</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span> <span class="n">samples</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the total memory usage for key, its value and associated</span>
<span class="sd">        administrative overheads.</span>

<span class="sd">        For nested data structures, ``samples`` is the number of elements to</span>
<span class="sd">        sample. If left unspecified, the server&#39;s default is 5. Use 0 to sample</span>
<span class="sd">        all elements.</span>

<span class="sd">        For more information see https://redis.io/commands/memory-usage</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">args</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="sa">b</span><span class="s2">&quot;SAMPLES&quot;</span><span class="p">,</span> <span class="n">samples</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;MEMORY USAGE&quot;</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">memory_purge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Attempts to purge dirty pages for reclamation by allocator</span>

<span class="sd">        For more information see https://redis.io/commands/memory-purge</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;MEMORY PURGE&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">latency_histogram</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function throws a NotImplementedError since it is intentionally</span>
<span class="sd">        not supported.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;LATENCY HISTOGRAM is intentionally not implemented in the client.&quot;</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">latency_history</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the raw data of the ``event``&#39;s latency spikes time series.</span>

<span class="sd">        For more information see https://redis.io/commands/latency-history</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;LATENCY HISTORY&quot;</span><span class="p">,</span> <span class="n">event</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">latency_latest</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reports the latest latency events logged.</span>

<span class="sd">        For more information see https://redis.io/commands/latency-latest</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;LATENCY LATEST&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">latency_reset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">events</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Resets the latency spikes time series of all, or only some, events.</span>

<span class="sd">        For more information see https://redis.io/commands/latency-reset</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;LATENCY RESET&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">events</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ping</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Ping the Redis server</span>

<span class="sd">        For more information see https://redis.io/commands/ping</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;PING&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">quit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Ask the server to close the connection.</span>

<span class="sd">        For more information see https://redis.io/commands/quit</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;QUIT&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">replicaof</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the replication settings of a redis replica, on the fly.</span>

<span class="sd">        Examples of valid arguments include:</span>

<span class="sd">        NO ONE (set no replication)</span>
<span class="sd">        host port (set to the host and port of a redis server)</span>

<span class="sd">        For more information see  https://redis.io/commands/replicaof</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;REPLICAOF&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Tell the Redis server to save its data to disk,</span>
<span class="sd">        blocking until the save is complete</span>

<span class="sd">        For more information see https://redis.io/commands/save</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;SAVE&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">shutdown</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">save</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">nosave</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">now</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">force</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">abort</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Shutdown the Redis server.  If Redis has persistence configured,</span>
<span class="sd">        data will be flushed before shutdown.</span>
<span class="sd">        It is possible to specify modifiers to alter the behavior of the command:</span>
<span class="sd">        ``save`` will force a DB saving operation even if no save points are configured.</span>
<span class="sd">        ``nosave`` will prevent a DB saving operation even if one or more save points</span>
<span class="sd">        are configured.</span>
<span class="sd">        ``now`` skips waiting for lagging replicas, i.e. it bypasses the first step in</span>
<span class="sd">        the shutdown sequence.</span>
<span class="sd">        ``force`` ignores any errors that would normally prevent the server from exiting</span>
<span class="sd">        ``abort`` cancels an ongoing shutdown and cannot be combined with other flags.</span>

<span class="sd">        For more information see https://redis.io/commands/shutdown</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">save</span> <span class="ow">and</span> <span class="n">nosave</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span><span class="s2">&quot;SHUTDOWN save and nosave cannot both be set&quot;</span><span class="p">)</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;SHUTDOWN&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">save</span><span class="p">:</span>
            <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;SAVE&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nosave</span><span class="p">:</span>
            <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;NOSAVE&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">now</span><span class="p">:</span>
            <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;NOW&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">force</span><span class="p">:</span>
            <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;FORCE&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">abort</span><span class="p">:</span>
            <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;ABORT&quot;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ConnectionError</span><span class="p">:</span>
            <span class="c1"># a ConnectionError here is expected</span>
            <span class="k">return</span>
        <span class="k">raise</span> <span class="n">RedisError</span><span class="p">(</span><span class="s2">&quot;SHUTDOWN seems to have failed.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">slaveof</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">host</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">port</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the server to be a replicated slave of the instance identified</span>
<span class="sd">        by the ``host`` and ``port``. If called without arguments, the</span>
<span class="sd">        instance is promoted to a master instead.</span>

<span class="sd">        For more information see https://redis.io/commands/slaveof</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">host</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">port</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;SLAVEOF&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;NO&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;ONE&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;SLAVEOF&quot;</span><span class="p">,</span> <span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">slowlog_get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the entries from the slowlog. If ``num`` is specified, get the</span>
<span class="sd">        most recent ``num`` items.</span>

<span class="sd">        For more information see https://redis.io/commands/slowlog-get</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">redis.client</span> <span class="kn">import</span> <span class="n">NEVER_DECODE</span>

        <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;SLOWLOG GET&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">num</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
        <span class="n">decode_responses</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_connection_kwargs</span><span class="p">()</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;decode_responses&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">decode_responses</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="n">NEVER_DECODE</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">slowlog_len</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of items in the slowlog</span>

<span class="sd">        For more information see https://redis.io/commands/slowlog-len</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;SLOWLOG LEN&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">slowlog_reset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove all items in the slowlog</span>

<span class="sd">        For more information see https://redis.io/commands/slowlog-reset</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;SLOWLOG RESET&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the server time as a 2-item tuple of ints:</span>
<span class="sd">        (seconds since epoch, microseconds into this second).</span>

<span class="sd">        For more information see https://redis.io/commands/time</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;TIME&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">wait</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_replicas</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">timeout</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Redis synchronous replication</span>
<span class="sd">        That returns the number of replicas that processed the query when</span>
<span class="sd">        we finally have at least ``num_replicas``, or when the ``timeout`` was</span>
<span class="sd">        reached.</span>

<span class="sd">        For more information see https://redis.io/commands/wait</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;WAIT&quot;</span><span class="p">,</span> <span class="n">num_replicas</span><span class="p">,</span> <span class="n">timeout</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">waitaof</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">num_local</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">num_replicas</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">timeout</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This command blocks the current client until all previous write</span>
<span class="sd">        commands by that client are acknowledged as having been fsynced</span>
<span class="sd">        to the AOF of the local Redis and/or at least the specified number</span>
<span class="sd">        of replicas.</span>

<span class="sd">        For more information see https://redis.io/commands/waitaof</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span>
            <span class="s2">&quot;WAITAOF&quot;</span><span class="p">,</span> <span class="n">num_local</span><span class="p">,</span> <span class="n">num_replicas</span><span class="p">,</span> <span class="n">timeout</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">hello</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function throws a NotImplementedError since it is intentionally</span>
<span class="sd">        not supported.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;HELLO is intentionally not implemented in the client.&quot;</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">failover</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function throws a NotImplementedError since it is intentionally</span>
<span class="sd">        not supported.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;FAILOVER is intentionally not implemented in the client.&quot;</span>
        <span class="p">)</span>


<span class="k">class</span> <span class="nc">AsyncManagementCommands</span><span class="p">(</span><span class="n">ManagementCommands</span><span class="p">):</span>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">command_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">command_info</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">debug_segfault</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">debug_segfault</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">memory_doctor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">memory_doctor</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">memory_help</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">memory_help</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">shutdown</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">save</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">nosave</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">now</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">force</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">abort</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Shutdown the Redis server.  If Redis has persistence configured,</span>
<span class="sd">        data will be flushed before shutdown.  If the &quot;save&quot; option is set,</span>
<span class="sd">        a data flush will be attempted even if there is no persistence</span>
<span class="sd">        configured.  If the &quot;nosave&quot; option is set, no data flush will be</span>
<span class="sd">        attempted.  The &quot;save&quot; and &quot;nosave&quot; options cannot both be set.</span>

<span class="sd">        For more information see https://redis.io/commands/shutdown</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">save</span> <span class="ow">and</span> <span class="n">nosave</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span><span class="s2">&quot;SHUTDOWN save and nosave cannot both be set&quot;</span><span class="p">)</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;SHUTDOWN&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">save</span><span class="p">:</span>
            <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;SAVE&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nosave</span><span class="p">:</span>
            <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;NOSAVE&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">now</span><span class="p">:</span>
            <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;NOW&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">force</span><span class="p">:</span>
            <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;FORCE&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">abort</span><span class="p">:</span>
            <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;ABORT&quot;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ConnectionError</span><span class="p">:</span>
            <span class="c1"># a ConnectionError here is expected</span>
            <span class="k">return</span>
        <span class="k">raise</span> <span class="n">RedisError</span><span class="p">(</span><span class="s2">&quot;SHUTDOWN seems to have failed.&quot;</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">BitFieldOperation</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Command builder for BITFIELD commands.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">client</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="s2">&quot;redis.client.Redis&quot;</span><span class="p">,</span> <span class="s2">&quot;redis.asyncio.client.Redis&quot;</span><span class="p">],</span>
        <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">default_overflow</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">client</span> <span class="o">=</span> <span class="n">client</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">key</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_default_overflow</span> <span class="o">=</span> <span class="n">default_overflow</span>
        <span class="c1"># for typing purposes, run the following in constructor and in reset()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">operations</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">EncodableT</span><span class="p">,</span> <span class="o">...</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_last_overflow</span> <span class="o">=</span> <span class="s2">&quot;WRAP&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reset the state of the instance to when it was constructed</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">operations</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_last_overflow</span> <span class="o">=</span> <span class="s2">&quot;WRAP&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">overflow</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_default_overflow</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_last_overflow</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">overflow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">overflow</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the overflow algorithm of successive INCRBY operations</span>
<span class="sd">        :param overflow: Overflow algorithm, one of WRAP, SAT, FAIL. See the</span>
<span class="sd">            Redis docs for descriptions of these algorithmsself.</span>
<span class="sd">        :returns: a :py:class:`BitFieldOperation` instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">overflow</span> <span class="o">=</span> <span class="n">overflow</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">overflow</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_last_overflow</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_last_overflow</span> <span class="o">=</span> <span class="n">overflow</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">operations</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s2">&quot;OVERFLOW&quot;</span><span class="p">,</span> <span class="n">overflow</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">incrby</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">fmt</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">offset</span><span class="p">:</span> <span class="n">BitfieldOffsetT</span><span class="p">,</span>
        <span class="n">increment</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">overflow</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Increment a bitfield by a given amount.</span>
<span class="sd">        :param fmt: format-string for the bitfield being updated, e.g. &#39;u8&#39;</span>
<span class="sd">            for an unsigned 8-bit integer.</span>
<span class="sd">        :param offset: offset (in number of bits). If prefixed with a</span>
<span class="sd">            &#39;#&#39;, this is an offset multiplier, e.g. given the arguments</span>
<span class="sd">            fmt=&#39;u8&#39;, offset=&#39;#2&#39;, the offset will be 16.</span>
<span class="sd">        :param int increment: value to increment the bitfield by.</span>
<span class="sd">        :param str overflow: overflow algorithm. Defaults to WRAP, but other</span>
<span class="sd">            acceptable values are SAT and FAIL. See the Redis docs for</span>
<span class="sd">            descriptions of these algorithms.</span>
<span class="sd">        :returns: a :py:class:`BitFieldOperation` instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">overflow</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">overflow</span><span class="p">(</span><span class="n">overflow</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">operations</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s2">&quot;INCRBY&quot;</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">increment</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fmt</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">offset</span><span class="p">:</span> <span class="n">BitfieldOffsetT</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the value of a given bitfield.</span>
<span class="sd">        :param fmt: format-string for the bitfield being read, e.g. &#39;u8&#39; for</span>
<span class="sd">            an unsigned 8-bit integer.</span>
<span class="sd">        :param offset: offset (in number of bits). If prefixed with a</span>
<span class="sd">            &#39;#&#39;, this is an offset multiplier, e.g. given the arguments</span>
<span class="sd">            fmt=&#39;u8&#39;, offset=&#39;#2&#39;, the offset will be 16.</span>
<span class="sd">        :returns: a :py:class:`BitFieldOperation` instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">operations</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s2">&quot;GET&quot;</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">offset</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fmt</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">offset</span><span class="p">:</span> <span class="n">BitfieldOffsetT</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the value of a given bitfield.</span>
<span class="sd">        :param fmt: format-string for the bitfield being read, e.g. &#39;u8&#39; for</span>
<span class="sd">            an unsigned 8-bit integer.</span>
<span class="sd">        :param offset: offset (in number of bits). If prefixed with a</span>
<span class="sd">            &#39;#&#39;, this is an offset multiplier, e.g. given the arguments</span>
<span class="sd">            fmt=&#39;u8&#39;, offset=&#39;#2&#39;, the offset will be 16.</span>
<span class="sd">        :param int value: value to set at the given position.</span>
<span class="sd">        :returns: a :py:class:`BitFieldOperation` instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">operations</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s2">&quot;SET&quot;</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">command</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">cmd</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;BITFIELD&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">ops</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">operations</span><span class="p">:</span>
            <span class="n">cmd</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">ops</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cmd</span>

    <span class="k">def</span> <span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Execute the operation(s) in a single BITFIELD command. The return value</span>
<span class="sd">        is a list of values corresponding to each operation. If the client</span>
<span class="sd">        used to create this instance was a pipeline, the list of values</span>
<span class="sd">        will be present within the pipeline&#39;s execute.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">command</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">command</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">client</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="o">*</span><span class="n">command</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">BasicKeyCommands</span><span class="p">(</span><span class="n">CommandsProtocol</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Redis basic key-based commands</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">EncodableT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Appends the string ``value`` to the value at ``key``. If ``key``</span>
<span class="sd">        doesn&#39;t already exist, create it with a value of ``value``.</span>
<span class="sd">        Returns the new length of the value at ``key``.</span>

<span class="sd">        For more information see https://redis.io/commands/append</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;APPEND&quot;</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">bitcount</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span>
        <span class="n">start</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">end</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the count of set bits in the value of ``key``.  Optional</span>
<span class="sd">        ``start`` and ``end`` parameters indicate which bytes to consider</span>

<span class="sd">        For more information see https://redis.io/commands/bitcount</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">params</span> <span class="o">=</span> <span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">end</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
            <span class="n">params</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">end</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">end</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">end</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span><span class="s2">&quot;Both start and end must be specified&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;BITCOUNT&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">params</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">bitfield</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="s2">&quot;redis.client.Redis&quot;</span><span class="p">,</span> <span class="s2">&quot;redis.asyncio.client.Redis&quot;</span><span class="p">],</span>
        <span class="n">key</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span>
        <span class="n">default_overflow</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BitFieldOperation</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a BitFieldOperation instance to conveniently construct one or</span>
<span class="sd">        more bitfield operations on ``key``.</span>

<span class="sd">        For more information see https://redis.io/commands/bitfield</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">BitFieldOperation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">default_overflow</span><span class="o">=</span><span class="n">default_overflow</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">bitfield_ro</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="s2">&quot;redis.client.Redis&quot;</span><span class="p">,</span> <span class="s2">&quot;redis.asyncio.client.Redis&quot;</span><span class="p">],</span>
        <span class="n">key</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span>
        <span class="n">encoding</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">offset</span><span class="p">:</span> <span class="n">BitfieldOffsetT</span><span class="p">,</span>
        <span class="n">items</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an array of the specified bitfield values</span>
<span class="sd">        where the first value is found using ``encoding`` and ``offset``</span>
<span class="sd">        parameters and remaining values are result of corresponding</span>
<span class="sd">        encoding/offset pairs in optional list ``items``</span>
<span class="sd">        Read-only variant of the BITFIELD command.</span>

<span class="sd">        For more information see https://redis.io/commands/bitfield_ro</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">params</span> <span class="o">=</span> <span class="p">[</span><span class="n">key</span><span class="p">,</span> <span class="s2">&quot;GET&quot;</span><span class="p">,</span> <span class="n">encoding</span><span class="p">,</span> <span class="n">offset</span><span class="p">]</span>

        <span class="n">items</span> <span class="o">=</span> <span class="n">items</span> <span class="ow">or</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">encoding</span><span class="p">,</span> <span class="n">offset</span> <span class="ow">in</span> <span class="n">items</span><span class="p">:</span>
            <span class="n">params</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s2">&quot;GET&quot;</span><span class="p">,</span> <span class="n">encoding</span><span class="p">,</span> <span class="n">offset</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;BITFIELD_RO&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">params</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">bitop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operation</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dest</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span> <span class="o">*</span><span class="n">keys</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform a bitwise operation using ``operation`` between ``keys`` and</span>
<span class="sd">        store the result in ``dest``.</span>

<span class="sd">        For more information see https://redis.io/commands/bitop</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;BITOP&quot;</span><span class="p">,</span> <span class="n">operation</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="o">*</span><span class="n">keys</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">bitpos</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span>
        <span class="n">bit</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">start</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">end</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the position of the first bit set to 1 or 0 in a string.</span>
<span class="sd">        ``start`` and ``end`` defines search range. The range is interpreted</span>
<span class="sd">        as a range of bytes and not a range of bits, so start=0 and end=2</span>
<span class="sd">        means to look at the first three bytes.</span>

<span class="sd">        For more information see https://redis.io/commands/bitpos</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">bit</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span><span class="s2">&quot;bit must be 0 or 1&quot;</span><span class="p">)</span>
        <span class="n">params</span> <span class="o">=</span> <span class="p">[</span><span class="n">key</span><span class="p">,</span> <span class="n">bit</span><span class="p">]</span>

        <span class="n">start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">params</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">end</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">end</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">end</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span><span class="s2">&quot;start argument is not set, when end is specified&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">mode</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;BITPOS&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">params</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">source</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">destination</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">destination_db</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">replace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Copy the value stored in the ``source`` key to the ``destination`` key.</span>

<span class="sd">        ``destination_db`` an alternative destination database. By default,</span>
<span class="sd">        the ``destination`` key is created in the source Redis database.</span>

<span class="sd">        ``replace`` whether the ``destination`` key should be removed before</span>
<span class="sd">        copying the value to it. By default, the value is not copied if</span>
<span class="sd">        the ``destination`` key already exists.</span>

<span class="sd">        For more information see https://redis.io/commands/copy</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">params</span> <span class="o">=</span> <span class="p">[</span><span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">destination_db</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s2">&quot;DB&quot;</span><span class="p">,</span> <span class="n">destination_db</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">replace</span><span class="p">:</span>
            <span class="n">params</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;REPLACE&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;COPY&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">params</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">decrby</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span> <span class="n">amount</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Decrements the value of ``key`` by ``amount``.  If no key exists,</span>
<span class="sd">        the value will be initialized as 0 - ``amount``</span>

<span class="sd">        For more information see https://redis.io/commands/decrby</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;DECRBY&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">amount</span><span class="p">)</span>

    <span class="n">decr</span> <span class="o">=</span> <span class="n">decrby</span>

    <span class="k">def</span> <span class="nf">delete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">names</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Delete one or more keys specified by ``names``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;DEL&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">names</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a serialized version of the value stored at the specified key.</span>
<span class="sd">        If key does not exist a nil bulk reply is returned.</span>

<span class="sd">        For more information see https://redis.io/commands/dump</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">redis.client</span> <span class="kn">import</span> <span class="n">NEVER_DECODE</span>

        <span class="n">options</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">options</span><span class="p">[</span><span class="n">NEVER_DECODE</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;DUMP&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">exists</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">names</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of ``names`` that exist</span>

<span class="sd">        For more information see https://redis.io/commands/exists</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;EXISTS&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">names</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="n">names</span><span class="p">)</span>

    <span class="fm">__contains__</span> <span class="o">=</span> <span class="n">exists</span>

    <span class="k">def</span> <span class="nf">expire</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span>
        <span class="n">time</span><span class="p">:</span> <span class="n">ExpiryT</span><span class="p">,</span>
        <span class="n">nx</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">xx</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">gt</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">lt</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set an expire flag on key ``name`` for ``time`` seconds with given</span>
<span class="sd">        ``option``. ``time`` can be represented by an integer or a Python timedelta</span>
<span class="sd">        object.</span>

<span class="sd">        Valid options are:</span>
<span class="sd">            NX -&gt; Set expiry only when the key has no expiry</span>
<span class="sd">            XX -&gt; Set expiry only when the key has an existing expiry</span>
<span class="sd">            GT -&gt; Set expiry only when the new expiry is greater than current one</span>
<span class="sd">            LT -&gt; Set expiry only when the new expiry is less than current one</span>

<span class="sd">        For more information see https://redis.io/commands/expire</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">timedelta</span><span class="p">):</span>
            <span class="n">time</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">())</span>

        <span class="n">exp_option</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">nx</span><span class="p">:</span>
            <span class="n">exp_option</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;NX&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">xx</span><span class="p">:</span>
            <span class="n">exp_option</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;XX&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">gt</span><span class="p">:</span>
            <span class="n">exp_option</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;GT&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">lt</span><span class="p">:</span>
            <span class="n">exp_option</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;LT&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;EXPIRE&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="o">*</span><span class="n">exp_option</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">expireat</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span>
        <span class="n">when</span><span class="p">:</span> <span class="n">AbsExpiryT</span><span class="p">,</span>
        <span class="n">nx</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">xx</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">gt</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">lt</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set an expire flag on key ``name`` with given ``option``. ``when``</span>
<span class="sd">        can be represented as an integer indicating unix time or a Python</span>
<span class="sd">        datetime object.</span>

<span class="sd">        Valid options are:</span>
<span class="sd">            -&gt; NX -- Set expiry only when the key has no expiry</span>
<span class="sd">            -&gt; XX -- Set expiry only when the key has an existing expiry</span>
<span class="sd">            -&gt; GT -- Set expiry only when the new expiry is greater than current one</span>
<span class="sd">            -&gt; LT -- Set expiry only when the new expiry is less than current one</span>

<span class="sd">        For more information see https://redis.io/commands/expireat</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">when</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">):</span>
            <span class="n">when</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">when</span><span class="o">.</span><span class="n">timestamp</span><span class="p">())</span>

        <span class="n">exp_option</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">nx</span><span class="p">:</span>
            <span class="n">exp_option</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;NX&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">xx</span><span class="p">:</span>
            <span class="n">exp_option</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;XX&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">gt</span><span class="p">:</span>
            <span class="n">exp_option</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;GT&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">lt</span><span class="p">:</span>
            <span class="n">exp_option</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;LT&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;EXPIREAT&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">when</span><span class="p">,</span> <span class="o">*</span><span class="n">exp_option</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">expiretime</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the absolute Unix timestamp (since January 1, 1970) in seconds</span>
<span class="sd">        at which the given key will expire.</span>

<span class="sd">        For more information see https://redis.io/commands/expiretime</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;EXPIRETIME&quot;</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the value at key ``name``, or None if the key doesn&#39;t exist</span>

<span class="sd">        For more information see https://redis.io/commands/get</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;GET&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">getdel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the value at key ``name`` and delete the key. This command</span>
<span class="sd">        is similar to GET, except for the fact that it also deletes</span>
<span class="sd">        the key on success (if and only if the key&#39;s value type</span>
<span class="sd">        is a string).</span>

<span class="sd">        For more information see https://redis.io/commands/getdel</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;GETDEL&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">getex</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span>
        <span class="n">ex</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ExpiryT</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">px</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ExpiryT</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">exat</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">AbsExpiryT</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">pxat</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">AbsExpiryT</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">persist</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the value of key and optionally set its expiration.</span>
<span class="sd">        GETEX is similar to GET, but is a write command with</span>
<span class="sd">        additional options. All time parameters can be given as</span>
<span class="sd">        datetime.timedelta or integers.</span>

<span class="sd">        ``ex`` sets an expire flag on key ``name`` for ``ex`` seconds.</span>

<span class="sd">        ``px`` sets an expire flag on key ``name`` for ``px`` milliseconds.</span>

<span class="sd">        ``exat`` sets an expire flag on key ``name`` for ``ex`` seconds,</span>
<span class="sd">        specified in unix time.</span>

<span class="sd">        ``pxat`` sets an expire flag on key ``name`` for ``ex`` milliseconds,</span>
<span class="sd">        specified in unix time.</span>

<span class="sd">        ``persist`` remove the time to live associated with ``name``.</span>

<span class="sd">        For more information see https://redis.io/commands/getex</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">opset</span> <span class="o">=</span> <span class="p">{</span><span class="n">ex</span><span class="p">,</span> <span class="n">px</span><span class="p">,</span> <span class="n">exat</span><span class="p">,</span> <span class="n">pxat</span><span class="p">}</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">opset</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">opset</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">persist</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span>
                <span class="s2">&quot;``ex``, ``px``, ``exat``, ``pxat``, &quot;</span>
                <span class="s2">&quot;and ``persist`` are mutually exclusive.&quot;</span>
            <span class="p">)</span>

        <span class="n">pieces</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">EncodableT</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># similar to set command</span>
        <span class="k">if</span> <span class="n">ex</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;EX&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ex</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">timedelta</span><span class="p">):</span>
                <span class="n">ex</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ex</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">())</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ex</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">px</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;PX&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">px</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">timedelta</span><span class="p">):</span>
                <span class="n">px</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">px</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">()</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">)</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">px</span><span class="p">)</span>
        <span class="c1"># similar to pexpireat command</span>
        <span class="k">if</span> <span class="n">exat</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;EXAT&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exat</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">):</span>
                <span class="n">exat</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">exat</span><span class="o">.</span><span class="n">timestamp</span><span class="p">())</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">exat</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pxat</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;PXAT&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pxat</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">):</span>
                <span class="n">pxat</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">pxat</span><span class="o">.</span><span class="n">timestamp</span><span class="p">()</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">)</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pxat</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">persist</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;PERSIST&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;GETEX&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="n">pieces</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the value at key ``name``, raises a KeyError if the key</span>
<span class="sd">        doesn&#39;t exist.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">value</span>
        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">getbit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span> <span class="n">offset</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an integer indicating the value of ``offset`` in ``name``</span>

<span class="sd">        For more information see https://redis.io/commands/getbit</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;GETBIT&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">getrange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the substring of the string value stored at ``key``,</span>
<span class="sd">        determined by the offsets ``start`` and ``end`` (both are inclusive)</span>

<span class="sd">        For more information see https://redis.io/commands/getrange</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;GETRANGE&quot;</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">getset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">EncodableT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the value at key ``name`` to ``value``</span>
<span class="sd">        and returns the old value at key ``name`` atomically.</span>

<span class="sd">        As per Redis 6.2, GETSET is considered deprecated.</span>
<span class="sd">        Please use SET with GET parameter in new code.</span>

<span class="sd">        For more information see https://redis.io/commands/getset</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;GETSET&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">incrby</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span> <span class="n">amount</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Increments the value of ``key`` by ``amount``.  If no key exists,</span>
<span class="sd">        the value will be initialized as ``amount``</span>

<span class="sd">        For more information see https://redis.io/commands/incrby</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;INCRBY&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">amount</span><span class="p">)</span>

    <span class="n">incr</span> <span class="o">=</span> <span class="n">incrby</span>

    <span class="k">def</span> <span class="nf">incrbyfloat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span> <span class="n">amount</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Increments the value at key ``name`` by floating ``amount``.</span>
<span class="sd">        If no key exists, the value will be initialized as ``amount``</span>

<span class="sd">        For more information see https://redis.io/commands/incrbyfloat</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;INCRBYFLOAT&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">amount</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">keys</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pattern</span><span class="p">:</span> <span class="n">PatternT</span> <span class="o">=</span> <span class="s2">&quot;*&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a list of keys matching ``pattern``</span>

<span class="sd">        For more information see https://redis.io/commands/keys</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;KEYS&quot;</span><span class="p">,</span> <span class="n">pattern</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">lmove</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">first_list</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">second_list</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">src</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;LEFT&quot;</span><span class="p">,</span> <span class="n">dest</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;RIGHT&quot;</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Atomically returns and removes the first/last element of a list,</span>
<span class="sd">        pushing it as the first/last element on the destination list.</span>
<span class="sd">        Returns the element being popped and pushed.</span>

<span class="sd">        For more information see https://redis.io/commands/lmove</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">params</span> <span class="o">=</span> <span class="p">[</span><span class="n">first_list</span><span class="p">,</span> <span class="n">second_list</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">dest</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;LMOVE&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">params</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">blmove</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">first_list</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">second_list</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">timeout</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">src</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;LEFT&quot;</span><span class="p">,</span>
        <span class="n">dest</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;RIGHT&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Blocking version of lmove.</span>

<span class="sd">        For more information see https://redis.io/commands/blmove</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">params</span> <span class="o">=</span> <span class="p">[</span><span class="n">first_list</span><span class="p">,</span> <span class="n">second_list</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">timeout</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;BLMOVE&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">params</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">mget</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keys</span><span class="p">:</span> <span class="n">KeysT</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">EncodableT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a list of values ordered identically to ``keys``</span>

<span class="sd">        For more information see https://redis.io/commands/mget</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">redis.client</span> <span class="kn">import</span> <span class="n">EMPTY_RESPONSE</span>

        <span class="n">args</span> <span class="o">=</span> <span class="n">list_or_args</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
        <span class="n">options</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">args</span><span class="p">:</span>
            <span class="n">options</span><span class="p">[</span><span class="n">EMPTY_RESPONSE</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">options</span><span class="p">[</span><span class="s2">&quot;keys&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">args</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;MGET&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">mset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mapping</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">AnyKeyT</span><span class="p">,</span> <span class="n">EncodableT</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets key/values based on a mapping. Mapping is a dictionary of</span>
<span class="sd">        key/value pairs. Both keys and values should be strings or types that</span>
<span class="sd">        can be cast to a string via str().</span>

<span class="sd">        For more information see https://redis.io/commands/mset</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">items</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">mapping</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">items</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pair</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;MSET&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">items</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">msetnx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mapping</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">AnyKeyT</span><span class="p">,</span> <span class="n">EncodableT</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets key/values based on a mapping if none of the keys are already set.</span>
<span class="sd">        Mapping is a dictionary of key/value pairs. Both keys and values</span>
<span class="sd">        should be strings or types that can be cast to a string via str().</span>
<span class="sd">        Returns a boolean indicating if the operation was successful.</span>

<span class="sd">        For more information see https://redis.io/commands/msetnx</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">items</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">mapping</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">items</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pair</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;MSETNX&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">items</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">move</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span> <span class="n">db</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Moves the key ``name`` to a different Redis database ``db``</span>

<span class="sd">        For more information see https://redis.io/commands/move</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;MOVE&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">db</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">persist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes an expiration on ``name``</span>

<span class="sd">        For more information see https://redis.io/commands/persist</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;PERSIST&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pexpire</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span>
        <span class="n">time</span><span class="p">:</span> <span class="n">ExpiryT</span><span class="p">,</span>
        <span class="n">nx</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">xx</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">gt</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">lt</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set an expire flag on key ``name`` for ``time`` milliseconds</span>
<span class="sd">        with given ``option``. ``time`` can be represented by an</span>
<span class="sd">        integer or a Python timedelta object.</span>

<span class="sd">        Valid options are:</span>
<span class="sd">            NX -&gt; Set expiry only when the key has no expiry</span>
<span class="sd">            XX -&gt; Set expiry only when the key has an existing expiry</span>
<span class="sd">            GT -&gt; Set expiry only when the new expiry is greater than current one</span>
<span class="sd">            LT -&gt; Set expiry only when the new expiry is less than current one</span>

<span class="sd">        For more information see https://redis.io/commands/pexpire</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">timedelta</span><span class="p">):</span>
            <span class="n">time</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">()</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">)</span>

        <span class="n">exp_option</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">nx</span><span class="p">:</span>
            <span class="n">exp_option</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;NX&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">xx</span><span class="p">:</span>
            <span class="n">exp_option</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;XX&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">gt</span><span class="p">:</span>
            <span class="n">exp_option</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;GT&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">lt</span><span class="p">:</span>
            <span class="n">exp_option</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;LT&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;PEXPIRE&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="o">*</span><span class="n">exp_option</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pexpireat</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span>
        <span class="n">when</span><span class="p">:</span> <span class="n">AbsExpiryT</span><span class="p">,</span>
        <span class="n">nx</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">xx</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">gt</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">lt</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set an expire flag on key ``name`` with given ``option``. ``when``</span>
<span class="sd">        can be represented as an integer representing unix time in</span>
<span class="sd">        milliseconds (unix time * 1000) or a Python datetime object.</span>

<span class="sd">        Valid options are:</span>
<span class="sd">            NX -&gt; Set expiry only when the key has no expiry</span>
<span class="sd">            XX -&gt; Set expiry only when the key has an existing expiry</span>
<span class="sd">            GT -&gt; Set expiry only when the new expiry is greater than current one</span>
<span class="sd">            LT -&gt; Set expiry only when the new expiry is less than current one</span>

<span class="sd">        For more information see https://redis.io/commands/pexpireat</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">when</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">):</span>
            <span class="n">when</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">when</span><span class="o">.</span><span class="n">timestamp</span><span class="p">()</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">)</span>
        <span class="n">exp_option</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">nx</span><span class="p">:</span>
            <span class="n">exp_option</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;NX&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">xx</span><span class="p">:</span>
            <span class="n">exp_option</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;XX&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">gt</span><span class="p">:</span>
            <span class="n">exp_option</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;GT&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">lt</span><span class="p">:</span>
            <span class="n">exp_option</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;LT&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;PEXPIREAT&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">when</span><span class="p">,</span> <span class="o">*</span><span class="n">exp_option</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pexpiretime</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the absolute Unix timestamp (since January 1, 1970) in milliseconds</span>
<span class="sd">        at which the given key will expire.</span>

<span class="sd">        For more information see https://redis.io/commands/pexpiretime</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;PEXPIRETIME&quot;</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">psetex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span> <span class="n">time_ms</span><span class="p">:</span> <span class="n">ExpiryT</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">EncodableT</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the value of key ``name`` to ``value`` that expires in ``time_ms``</span>
<span class="sd">        milliseconds. ``time_ms`` can be represented by an integer or a Python</span>
<span class="sd">        timedelta object</span>

<span class="sd">        For more information see https://redis.io/commands/psetex</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">time_ms</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">timedelta</span><span class="p">):</span>
            <span class="n">time_ms</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">time_ms</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">()</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;PSETEX&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">time_ms</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pttl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of milliseconds until the key ``name`` will expire</span>

<span class="sd">        For more information see https://redis.io/commands/pttl</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;PTTL&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">hrandfield</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">withvalues</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a random field from the hash value stored at key.</span>

<span class="sd">        count: if the argument is positive, return an array of distinct fields.</span>
<span class="sd">        If called with a negative count, the behavior changes and the command</span>
<span class="sd">        is allowed to return the same field multiple times. In this case,</span>
<span class="sd">        the number of returned fields is the absolute value of the</span>
<span class="sd">        specified count.</span>
<span class="sd">        withvalues: The optional WITHVALUES modifier changes the reply so it</span>
<span class="sd">        includes the respective values of the randomly selected hash fields.</span>

<span class="sd">        For more information see https://redis.io/commands/hrandfield</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">params</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">count</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">count</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">withvalues</span><span class="p">:</span>
            <span class="n">params</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;WITHVALUES&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;HRANDFIELD&quot;</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="o">*</span><span class="n">params</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">randomkey</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the name of a random key</span>

<span class="sd">        For more information see https://redis.io/commands/randomkey</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;RANDOMKEY&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">rename</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span> <span class="n">dst</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rename key ``src`` to ``dst``</span>

<span class="sd">        For more information see https://redis.io/commands/rename</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;RENAME&quot;</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">renamenx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span> <span class="n">dst</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rename key ``src`` to ``dst`` if ``dst`` doesn&#39;t already exist</span>

<span class="sd">        For more information see https://redis.io/commands/renamenx</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;RENAMENX&quot;</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">restore</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span>
        <span class="n">ttl</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">value</span><span class="p">:</span> <span class="n">EncodableT</span><span class="p">,</span>
        <span class="n">replace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">absttl</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">idletime</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">frequency</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a key using the provided serialized value, previously obtained</span>
<span class="sd">        using DUMP.</span>

<span class="sd">        ``replace`` allows an existing key on ``name`` to be overridden. If</span>
<span class="sd">        it&#39;s not specified an error is raised on collision.</span>

<span class="sd">        ``absttl`` if True, specified ``ttl`` should represent an absolute Unix</span>
<span class="sd">        timestamp in milliseconds in which the key will expire. (Redis 5.0 or</span>
<span class="sd">        greater).</span>

<span class="sd">        ``idletime`` Used for eviction, this is the number of seconds the</span>
<span class="sd">        key must be idle, prior to execution.</span>

<span class="sd">        ``frequency`` Used for eviction, this is the frequency counter of</span>
<span class="sd">        the object stored at the key, prior to execution.</span>

<span class="sd">        For more information see https://redis.io/commands/restore</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">params</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span><span class="p">,</span> <span class="n">ttl</span><span class="p">,</span> <span class="n">value</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">replace</span><span class="p">:</span>
            <span class="n">params</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;REPLACE&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">absttl</span><span class="p">:</span>
            <span class="n">params</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;ABSTTL&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">idletime</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;IDLETIME&quot;</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">params</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">idletime</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span><span class="s2">&quot;idletimemust be an integer&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">frequency</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;FREQ&quot;</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">params</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">frequency</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span><span class="s2">&quot;frequency must be an integer&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;RESTORE&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">params</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span>
        <span class="n">value</span><span class="p">:</span> <span class="n">EncodableT</span><span class="p">,</span>
        <span class="n">ex</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ExpiryT</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">px</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ExpiryT</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">nx</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">xx</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">keepttl</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">get</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">exat</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">AbsExpiryT</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">pxat</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">AbsExpiryT</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the value at key ``name`` to ``value``</span>

<span class="sd">        ``ex`` sets an expire flag on key ``name`` for ``ex`` seconds.</span>

<span class="sd">        ``px`` sets an expire flag on key ``name`` for ``px`` milliseconds.</span>

<span class="sd">        ``nx`` if set to True, set the value at key ``name`` to ``value`` only</span>
<span class="sd">            if it does not exist.</span>

<span class="sd">        ``xx`` if set to True, set the value at key ``name`` to ``value`` only</span>
<span class="sd">            if it already exists.</span>

<span class="sd">        ``keepttl`` if True, retain the time to live associated with the key.</span>
<span class="sd">            (Available since Redis 6.0)</span>

<span class="sd">        ``get`` if True, set the value at key ``name`` to ``value`` and return</span>
<span class="sd">            the old value stored at key, or None if the key did not exist.</span>
<span class="sd">            (Available since Redis 6.2)</span>

<span class="sd">        ``exat`` sets an expire flag on key ``name`` for ``ex`` seconds,</span>
<span class="sd">            specified in unix time.</span>

<span class="sd">        ``pxat`` sets an expire flag on key ``name`` for ``ex`` milliseconds,</span>
<span class="sd">            specified in unix time.</span>

<span class="sd">        For more information see https://redis.io/commands/set</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pieces</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">EncodableT</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">]</span>
        <span class="n">options</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">ex</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;EX&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ex</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">timedelta</span><span class="p">):</span>
                <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">ex</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">()))</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ex</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ex</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ex</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">ex</span><span class="o">.</span><span class="n">isdigit</span><span class="p">():</span>
                <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">ex</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span><span class="s2">&quot;ex must be datetime.timedelta or int&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">px</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;PX&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">px</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">timedelta</span><span class="p">):</span>
                <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">px</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">()</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">))</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">px</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">px</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span><span class="s2">&quot;px must be datetime.timedelta or int&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">exat</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;EXAT&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exat</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">):</span>
                <span class="n">exat</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">exat</span><span class="o">.</span><span class="n">timestamp</span><span class="p">())</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">exat</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pxat</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;PXAT&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pxat</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">):</span>
                <span class="n">pxat</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">pxat</span><span class="o">.</span><span class="n">timestamp</span><span class="p">()</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">)</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pxat</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">keepttl</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;KEEPTTL&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">nx</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;NX&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">xx</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;XX&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">get</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;GET&quot;</span><span class="p">)</span>
            <span class="n">options</span><span class="p">[</span><span class="s2">&quot;get&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;SET&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">pieces</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">EncodableT</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">setbit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span> <span class="n">offset</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Flag the ``offset`` in ``name`` as ``value``. Returns an integer</span>
<span class="sd">        indicating the previous value of ``offset``.</span>

<span class="sd">        For more information see https://redis.io/commands/setbit</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">value</span> <span class="ow">and</span> <span class="mi">1</span> <span class="ow">or</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;SETBIT&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">setex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span> <span class="n">time</span><span class="p">:</span> <span class="n">ExpiryT</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">EncodableT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the value of key ``name`` to ``value`` that expires in ``time``</span>
<span class="sd">        seconds. ``time`` can be represented by an integer or a Python</span>
<span class="sd">        timedelta object.</span>

<span class="sd">        For more information see https://redis.io/commands/setex</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">timedelta</span><span class="p">):</span>
            <span class="n">time</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">())</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;SETEX&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">setnx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">EncodableT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the value of key ``name`` to ``value`` if key doesn&#39;t exist</span>

<span class="sd">        For more information see https://redis.io/commands/setnx</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;SETNX&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">setrange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span> <span class="n">offset</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">EncodableT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overwrite bytes in the value of ``name`` starting at ``offset`` with</span>
<span class="sd">        ``value``. If ``offset`` plus the length of ``value`` exceeds the</span>
<span class="sd">        length of the original value, the new value will be larger than before.</span>
<span class="sd">        If ``offset`` exceeds the length of the original value, null bytes</span>
<span class="sd">        will be used to pad between the end of the previous value and the start</span>
<span class="sd">        of what&#39;s being injected.</span>

<span class="sd">        Returns the length of the new string.</span>

<span class="sd">        For more information see https://redis.io/commands/setrange</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;SETRANGE&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">stralgo</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">algo</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;LCS&quot;</span><span class="p">],</span>
        <span class="n">value1</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span>
        <span class="n">value2</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span>
        <span class="n">specific_argument</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;strings&quot;</span><span class="p">],</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;keys&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="s2">&quot;strings&quot;</span><span class="p">,</span>
        <span class="nb">len</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">idx</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">minmatchlen</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">withmatchlen</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Implements complex algorithms that operate on strings.</span>
<span class="sd">        Right now the only algorithm implemented is the LCS algorithm</span>
<span class="sd">        (longest common substring). However new algorithms could be</span>
<span class="sd">        implemented in the future.</span>

<span class="sd">        ``algo`` Right now must be LCS</span>
<span class="sd">        ``value1`` and ``value2`` Can be two strings or two keys</span>
<span class="sd">        ``specific_argument`` Specifying if the arguments to the algorithm</span>
<span class="sd">        will be keys or strings. strings is the default.</span>
<span class="sd">        ``len`` Returns just the len of the match.</span>
<span class="sd">        ``idx`` Returns the match positions in each string.</span>
<span class="sd">        ``minmatchlen`` Restrict the list of matches to the ones of a given</span>
<span class="sd">        minimal length. Can be provided only when ``idx`` set to True.</span>
<span class="sd">        ``withmatchlen`` Returns the matches with the len of the match.</span>
<span class="sd">        Can be provided only when ``idx`` set to True.</span>

<span class="sd">        For more information see https://redis.io/commands/stralgo</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># check validity</span>
        <span class="n">supported_algo</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;LCS&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">algo</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">supported_algo</span><span class="p">:</span>
            <span class="n">supported_algos_str</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">supported_algo</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The supported algorithms are: </span><span class="si">{</span><span class="n">supported_algos_str</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">specific_argument</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;keys&quot;</span><span class="p">,</span> <span class="s2">&quot;strings&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span><span class="s2">&quot;specific_argument can be only keys or strings&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span> <span class="ow">and</span> <span class="n">idx</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span><span class="s2">&quot;len and idx cannot be provided together.&quot;</span><span class="p">)</span>

        <span class="n">pieces</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">EncodableT</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">algo</span><span class="p">,</span> <span class="n">specific_argument</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span> <span class="n">value1</span><span class="p">,</span> <span class="n">value2</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;LEN&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">idx</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;IDX&quot;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="nb">int</span><span class="p">(</span><span class="n">minmatchlen</span><span class="p">)</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="sa">b</span><span class="s2">&quot;MINMATCHLEN&quot;</span><span class="p">,</span> <span class="n">minmatchlen</span><span class="p">])</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">if</span> <span class="n">withmatchlen</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;WITHMATCHLEN&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span>
            <span class="s2">&quot;STRALGO&quot;</span><span class="p">,</span>
            <span class="o">*</span><span class="n">pieces</span><span class="p">,</span>
            <span class="nb">len</span><span class="o">=</span><span class="nb">len</span><span class="p">,</span>
            <span class="n">idx</span><span class="o">=</span><span class="n">idx</span><span class="p">,</span>
            <span class="n">minmatchlen</span><span class="o">=</span><span class="n">minmatchlen</span><span class="p">,</span>
            <span class="n">withmatchlen</span><span class="o">=</span><span class="n">withmatchlen</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">strlen</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of bytes stored in the value of ``name``</span>

<span class="sd">        For more information see https://redis.io/commands/strlen</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;STRLEN&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">substr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a substring of the string at key ``name``. ``start`` and ``end``</span>
<span class="sd">        are 0-based integers specifying the portion of the string to return.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;SUBSTR&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">touch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Alters the last access time of a key(s) ``*args``. A key is ignored</span>
<span class="sd">        if it does not exist.</span>

<span class="sd">        For more information see https://redis.io/commands/touch</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;TOUCH&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ttl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of seconds until the key ``name`` will expire</span>

<span class="sd">        For more information see https://redis.io/commands/ttl</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;TTL&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the type of key ``name``</span>

<span class="sd">        For more information see https://redis.io/commands/type</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;TYPE&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">watch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">names</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Watches the values at keys ``names``, or None if the key doesn&#39;t exist</span>

<span class="sd">        For more information see https://redis.io/commands/watch</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="ne">DeprecationWarning</span><span class="p">(</span><span class="s2">&quot;Call WATCH from a Pipeline object&quot;</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">unwatch</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Unwatches the value at key ``name``, or None of the key doesn&#39;t exist</span>

<span class="sd">        For more information see https://redis.io/commands/unwatch</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="ne">DeprecationWarning</span><span class="p">(</span><span class="s2">&quot;Call UNWATCH from a Pipeline object&quot;</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">unlink</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">names</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Unlink one or more keys specified by ``names``</span>

<span class="sd">        For more information see https://redis.io/commands/unlink</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;UNLINK&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">names</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">lcs</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key1</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">key2</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="nb">len</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">idx</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">minmatchlen</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">withmatchlen</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">list</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find the longest common subsequence between ``key1`` and ``key2``.</span>
<span class="sd">        If ``len`` is true the length of the match will will be returned.</span>
<span class="sd">        If ``idx`` is true the match position in each strings will be returned.</span>
<span class="sd">        ``minmatchlen`` restrict the list of matches to the ones of</span>
<span class="sd">        the given ``minmatchlen``.</span>
<span class="sd">        If ``withmatchlen`` the length of the match also will be returned.</span>
<span class="sd">        For more information see https://redis.io/commands/lcs</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pieces</span> <span class="o">=</span> <span class="p">[</span><span class="n">key1</span><span class="p">,</span> <span class="n">key2</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;LEN&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">idx</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;IDX&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">minmatchlen</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s2">&quot;MINMATCHLEN&quot;</span><span class="p">,</span> <span class="n">minmatchlen</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">withmatchlen</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;WITHMATCHLEN&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;LCS&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">pieces</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="p">[</span><span class="n">key1</span><span class="p">,</span> <span class="n">key2</span><span class="p">])</span>


<span class="k">class</span> <span class="nc">AsyncBasicKeyCommands</span><span class="p">(</span><span class="n">BasicKeyCommands</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Async Redis client does not support class deletion&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Async Redis client does not support class inclusion&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Async Redis client does not support class retrieval&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">EncodableT</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Async Redis client does not support class assignment&quot;</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">watch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">names</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">watch</span><span class="p">(</span><span class="o">*</span><span class="n">names</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">unwatch</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">unwatch</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">ListCommands</span><span class="p">(</span><span class="n">CommandsProtocol</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Redis commands for List data type.</span>
<span class="sd">    see: https://redis.io/topics/data-types#lists</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">blpop</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">keys</span><span class="p">:</span> <span class="n">List</span><span class="p">,</span> <span class="n">timeout</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Awaitable</span><span class="p">[</span><span class="nb">list</span><span class="p">],</span> <span class="nb">list</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        LPOP a value off of the first non-empty list</span>
<span class="sd">        named in the ``keys`` list.</span>

<span class="sd">        If none of the lists in ``keys`` has a value to LPOP, then block</span>
<span class="sd">        for ``timeout`` seconds, or until a value gets pushed on to one</span>
<span class="sd">        of the lists.</span>

<span class="sd">        If timeout is 0, then block indefinitely.</span>

<span class="sd">        For more information see https://redis.io/commands/blpop</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">timeout</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">timeout</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="n">list_or_args</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">timeout</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;BLPOP&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">keys</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">brpop</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">keys</span><span class="p">:</span> <span class="n">List</span><span class="p">,</span> <span class="n">timeout</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Awaitable</span><span class="p">[</span><span class="nb">list</span><span class="p">],</span> <span class="nb">list</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        RPOP a value off of the first non-empty list</span>
<span class="sd">        named in the ``keys`` list.</span>

<span class="sd">        If none of the lists in ``keys`` has a value to RPOP, then block</span>
<span class="sd">        for ``timeout`` seconds, or until a value gets pushed on to one</span>
<span class="sd">        of the lists.</span>

<span class="sd">        If timeout is 0, then block indefinitely.</span>

<span class="sd">        For more information see https://redis.io/commands/brpop</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">timeout</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">timeout</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="n">list_or_args</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">timeout</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;BRPOP&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">keys</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">brpoplpush</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dst</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">timeout</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Awaitable</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pop a value off the tail of ``src``, push it on the head of ``dst``</span>
<span class="sd">        and then return it.</span>

<span class="sd">        This command blocks until a value is in ``src`` or until ``timeout``</span>
<span class="sd">        seconds elapse, whichever is first. A ``timeout`` value of 0 blocks</span>
<span class="sd">        forever.</span>

<span class="sd">        For more information see https://redis.io/commands/brpoplpush</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">timeout</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">timeout</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;BRPOPLPUSH&quot;</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">timeout</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">blmpop</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">timeout</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">numkeys</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">direction</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">count</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pop ``count`` values (default 1) from first non-empty in the list</span>
<span class="sd">        of provided key names.</span>

<span class="sd">        When all lists are empty this command blocks the connection until another</span>
<span class="sd">        client pushes to it or until the timeout, timeout of 0 blocks indefinitely</span>

<span class="sd">        For more information see https://redis.io/commands/blmpop</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">timeout</span><span class="p">,</span> <span class="n">numkeys</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="s2">&quot;COUNT&quot;</span><span class="p">,</span> <span class="n">count</span><span class="p">]</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;BLMPOP&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">lmpop</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">num_keys</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">direction</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">count</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Awaitable</span><span class="p">[</span><span class="nb">list</span><span class="p">],</span> <span class="nb">list</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pop ``count`` values (default 1) first non-empty list key from the list</span>
<span class="sd">        of args provided key names.</span>

<span class="sd">        For more information see https://redis.io/commands/lmpop</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">num_keys</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">direction</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">count</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">args</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s2">&quot;COUNT&quot;</span><span class="p">,</span> <span class="n">count</span><span class="p">])</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;LMPOP&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">lindex</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">int</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Awaitable</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the item from list ``name`` at position ``index``</span>

<span class="sd">        Negative indexes are supported and will return an item at the</span>
<span class="sd">        end of the list</span>

<span class="sd">        For more information see https://redis.io/commands/lindex</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;LINDEX&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">linsert</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">where</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">refvalue</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Awaitable</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Insert ``value`` in list ``name`` either immediately before or after</span>
<span class="sd">        [``where``] ``refvalue``</span>

<span class="sd">        Returns the new length of the list on success or -1 if ``refvalue``</span>
<span class="sd">        is not in the list.</span>

<span class="sd">        For more information see https://redis.io/commands/linsert</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;LINSERT&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span> <span class="n">refvalue</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">llen</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Awaitable</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the length of the list ``name``</span>

<span class="sd">        For more information see https://redis.io/commands/llen</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;LLEN&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">lpop</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">count</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Awaitable</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="kc">None</span><span class="p">]],</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="kc">None</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes and returns the first elements of the list ``name``.</span>

<span class="sd">        By default, the command pops a single element from the beginning of</span>
<span class="sd">        the list. When provided with the optional ``count`` argument, the reply</span>
<span class="sd">        will consist of up to count elements, depending on the list&#39;s length.</span>

<span class="sd">        For more information see https://redis.io/commands/lpop</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">count</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;LPOP&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;LPOP&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">lpush</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">*</span><span class="n">values</span><span class="p">:</span> <span class="n">FieldT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Awaitable</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Push ``values`` onto the head of the list ``name``</span>

<span class="sd">        For more information see https://redis.io/commands/lpush</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;LPUSH&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="n">values</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">lpushx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">*</span><span class="n">values</span><span class="p">:</span> <span class="n">FieldT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Awaitable</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Push ``value`` onto the head of the list ``name`` if ``name`` exists</span>

<span class="sd">        For more information see https://redis.io/commands/lpushx</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;LPUSHX&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="n">values</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">lrange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Awaitable</span><span class="p">[</span><span class="nb">list</span><span class="p">],</span> <span class="nb">list</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a slice of the list ``name`` between</span>
<span class="sd">        position ``start`` and ``end``</span>

<span class="sd">        ``start`` and ``end`` can be negative numbers just like</span>
<span class="sd">        Python slicing notation</span>

<span class="sd">        For more information see https://redis.io/commands/lrange</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;LRANGE&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">lrem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">count</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Awaitable</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove the first ``count`` occurrences of elements equal to ``value``</span>
<span class="sd">        from the list stored at ``name``.</span>

<span class="sd">        The count argument influences the operation in the following ways:</span>
<span class="sd">            count &gt; 0: Remove elements equal to value moving from head to tail.</span>
<span class="sd">            count &lt; 0: Remove elements equal to value moving from tail to head.</span>
<span class="sd">            count = 0: Remove all elements equal to value.</span>

<span class="sd">            For more information see https://redis.io/commands/lrem</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;LREM&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">lset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Awaitable</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set element at ``index`` of list ``name`` to ``value``</span>

<span class="sd">        For more information see https://redis.io/commands/lset</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;LSET&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ltrim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Awaitable</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Trim the list ``name``, removing all values not within the slice</span>
<span class="sd">        between ``start`` and ``end``</span>

<span class="sd">        ``start`` and ``end`` can be negative numbers just like</span>
<span class="sd">        Python slicing notation</span>

<span class="sd">        For more information see https://redis.io/commands/ltrim</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;LTRIM&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">rpop</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">count</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Awaitable</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="kc">None</span><span class="p">]],</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="kc">None</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes and returns the last elements of the list ``name``.</span>

<span class="sd">        By default, the command pops a single element from the end of the list.</span>
<span class="sd">        When provided with the optional ``count`` argument, the reply will</span>
<span class="sd">        consist of up to count elements, depending on the list&#39;s length.</span>

<span class="sd">        For more information see https://redis.io/commands/rpop</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">count</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;RPOP&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;RPOP&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">rpoplpush</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dst</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Awaitable</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        RPOP a value off of the ``src`` list and atomically LPUSH it</span>
<span class="sd">        on to the ``dst`` list.  Returns the value.</span>

<span class="sd">        For more information see https://redis.io/commands/rpoplpush</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;RPOPLPUSH&quot;</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">rpush</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">*</span><span class="n">values</span><span class="p">:</span> <span class="n">FieldT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Awaitable</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Push ``values`` onto the tail of the list ``name``</span>

<span class="sd">        For more information see https://redis.io/commands/rpush</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;RPUSH&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="n">values</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">rpushx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">*</span><span class="n">values</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Awaitable</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Push ``value`` onto the tail of the list ``name`` if ``name`` exists</span>

<span class="sd">        For more information see https://redis.io/commands/rpushx</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;RPUSHX&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="n">values</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">lpos</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">rank</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">count</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">maxlen</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get position of ``value`` within the list ``name``</span>

<span class="sd">         If specified, ``rank`` indicates the &quot;rank&quot; of the first element to</span>
<span class="sd">         return in case there are multiple copies of ``value`` in the list.</span>
<span class="sd">         By default, LPOS returns the position of the first occurrence of</span>
<span class="sd">         ``value`` in the list. When ``rank`` 2, LPOS returns the position of</span>
<span class="sd">         the second ``value`` in the list. If ``rank`` is negative, LPOS</span>
<span class="sd">         searches the list in reverse. For example, -1 would return the</span>
<span class="sd">         position of the last occurrence of ``value`` and -2 would return the</span>
<span class="sd">         position of the next to last occurrence of ``value``.</span>

<span class="sd">         If specified, ``count`` indicates that LPOS should return a list of</span>
<span class="sd">         up to ``count`` positions. A ``count`` of 2 would return a list of</span>
<span class="sd">         up to 2 positions. A ``count`` of 0 returns a list of all positions</span>
<span class="sd">         matching ``value``. When ``count`` is specified and but ``value``</span>
<span class="sd">         does not exist in the list, an empty list is returned.</span>

<span class="sd">         If specified, ``maxlen`` indicates the maximum number of list</span>
<span class="sd">         elements to scan. A ``maxlen`` of 1000 will only return the</span>
<span class="sd">         position(s) of items within the first 1000 entries in the list.</span>
<span class="sd">         A ``maxlen`` of 0 (the default) will scan the entire list.</span>

<span class="sd">         For more information see https://redis.io/commands/lpos</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pieces</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">EncodableT</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">rank</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s2">&quot;RANK&quot;</span><span class="p">,</span> <span class="n">rank</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">count</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s2">&quot;COUNT&quot;</span><span class="p">,</span> <span class="n">count</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">maxlen</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s2">&quot;MAXLEN&quot;</span><span class="p">,</span> <span class="n">maxlen</span><span class="p">])</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;LPOS&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">pieces</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">sort</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">start</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">num</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">by</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">get</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">desc</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">alpha</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">store</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">groups</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sort and return the list, set or sorted set at ``name``.</span>

<span class="sd">        ``start`` and ``num`` allow for paging through the sorted data</span>

<span class="sd">        ``by`` allows using an external key to weight and sort the items.</span>
<span class="sd">            Use an &quot;*&quot; to indicate where in the key the item value is located</span>

<span class="sd">        ``get`` allows for returning items from external keys rather than the</span>
<span class="sd">            sorted data itself.  Use an &quot;*&quot; to indicate where in the key</span>
<span class="sd">            the item value is located</span>

<span class="sd">        ``desc`` allows for reversing the sort</span>

<span class="sd">        ``alpha`` allows for sorting lexicographically rather than numerically</span>

<span class="sd">        ``store`` allows for storing the result of the sort into</span>
<span class="sd">            the key ``store``</span>

<span class="sd">        ``groups`` if set to True and if ``get`` contains at least two</span>
<span class="sd">            elements, sort will return a list of tuples, each containing the</span>
<span class="sd">            values fetched from the arguments to ``get``.</span>

<span class="sd">        For more information see https://redis.io/commands/sort</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">num</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">num</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span><span class="s2">&quot;``start`` and ``num`` must both be specified&quot;</span><span class="p">)</span>

        <span class="n">pieces</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">EncodableT</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">by</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="sa">b</span><span class="s2">&quot;BY&quot;</span><span class="p">,</span> <span class="n">by</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">num</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="sa">b</span><span class="s2">&quot;LIMIT&quot;</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">num</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">get</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># If get is a string assume we want to get a single value.</span>
            <span class="c1"># Otherwise assume it&#39;s an interable and we want to get multiple</span>
            <span class="c1"># values. We can&#39;t just iterate blindly because strings are</span>
            <span class="c1"># iterable.</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">get</span><span class="p">,</span> <span class="p">(</span><span class="nb">bytes</span><span class="p">,</span> <span class="nb">str</span><span class="p">)):</span>
                <span class="n">pieces</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="sa">b</span><span class="s2">&quot;GET&quot;</span><span class="p">,</span> <span class="n">get</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">get</span><span class="p">:</span>
                    <span class="n">pieces</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="sa">b</span><span class="s2">&quot;GET&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">desc</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;DESC&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">alpha</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;ALPHA&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">store</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="sa">b</span><span class="s2">&quot;STORE&quot;</span><span class="p">,</span> <span class="n">store</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">groups</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">get</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">get</span><span class="p">,</span> <span class="p">(</span><span class="nb">bytes</span><span class="p">,</span> <span class="nb">str</span><span class="p">))</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">get</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span>
                    <span class="s1">&#39;when using &quot;groups&quot; the &quot;get&quot; argument &#39;</span>
                    <span class="s2">&quot;must be specified and contain at least &quot;</span>
                    <span class="s2">&quot;two keys&quot;</span>
                <span class="p">)</span>

        <span class="n">options</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;groups&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">get</span><span class="p">)</span> <span class="k">if</span> <span class="n">groups</span> <span class="k">else</span> <span class="kc">None</span><span class="p">}</span>
        <span class="n">options</span><span class="p">[</span><span class="s2">&quot;keys&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;SORT&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">pieces</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">sort_ro</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">start</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">num</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">by</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">get</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">desc</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">alpha</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the elements contained in the list, set or sorted set at key.</span>
<span class="sd">        (read-only variant of the SORT command)</span>

<span class="sd">        ``start`` and ``num`` allow for paging through the sorted data</span>

<span class="sd">        ``by`` allows using an external key to weight and sort the items.</span>
<span class="sd">            Use an &quot;*&quot; to indicate where in the key the item value is located</span>

<span class="sd">        ``get`` allows for returning items from external keys rather than the</span>
<span class="sd">            sorted data itself.  Use an &quot;*&quot; to indicate where in the key</span>
<span class="sd">            the item value is located</span>

<span class="sd">        ``desc`` allows for reversing the sort</span>

<span class="sd">        ``alpha`` allows for sorting lexicographically rather than numerically</span>

<span class="sd">        For more information see https://redis.io/commands/sort_ro</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span>
            <span class="n">key</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="n">num</span><span class="p">,</span> <span class="n">by</span><span class="o">=</span><span class="n">by</span><span class="p">,</span> <span class="n">get</span><span class="o">=</span><span class="n">get</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="n">desc</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span>
        <span class="p">)</span>


<span class="n">AsyncListCommands</span> <span class="o">=</span> <span class="n">ListCommands</span>


<span class="k">class</span> <span class="nc">ScanCommands</span><span class="p">(</span><span class="n">CommandsProtocol</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Redis SCAN commands.</span>
<span class="sd">    see: https://redis.io/commands/scan</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">scan</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">cursor</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">match</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">PatternT</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">count</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">_type</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Incrementally return lists of key names. Also return a cursor</span>
<span class="sd">        indicating the scan position.</span>

<span class="sd">        ``match`` allows for filtering the keys by pattern</span>

<span class="sd">        ``count`` provides a hint to Redis about the number of keys to</span>
<span class="sd">            return per batch.</span>

<span class="sd">        ``_type`` filters the returned values by a particular Redis type.</span>
<span class="sd">            Stock Redis instances allow for the following types:</span>
<span class="sd">            HASH, LIST, SET, STREAM, STRING, ZSET</span>
<span class="sd">            Additionally, Redis modules can expose other types as well.</span>

<span class="sd">        For more information see https://redis.io/commands/scan</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pieces</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">EncodableT</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">cursor</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">match</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="sa">b</span><span class="s2">&quot;MATCH&quot;</span><span class="p">,</span> <span class="n">match</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">count</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="sa">b</span><span class="s2">&quot;COUNT&quot;</span><span class="p">,</span> <span class="n">count</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="sa">b</span><span class="s2">&quot;TYPE&quot;</span><span class="p">,</span> <span class="n">_type</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;SCAN&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">pieces</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">scan_iter</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">match</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">PatternT</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">count</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">_type</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make an iterator using the SCAN command so that the client doesn&#39;t</span>
<span class="sd">        need to remember the cursor position.</span>

<span class="sd">        ``match`` allows for filtering the keys by pattern</span>

<span class="sd">        ``count`` provides a hint to Redis about the number of keys to</span>
<span class="sd">            return per batch.</span>

<span class="sd">        ``_type`` filters the returned values by a particular Redis type.</span>
<span class="sd">            Stock Redis instances allow for the following types:</span>
<span class="sd">            HASH, LIST, SET, STREAM, STRING, ZSET</span>
<span class="sd">            Additionally, Redis modules can expose other types as well.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cursor</span> <span class="o">=</span> <span class="s2">&quot;0&quot;</span>
        <span class="k">while</span> <span class="n">cursor</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">cursor</span><span class="p">,</span> <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scan</span><span class="p">(</span>
                <span class="n">cursor</span><span class="o">=</span><span class="n">cursor</span><span class="p">,</span> <span class="n">match</span><span class="o">=</span><span class="n">match</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="n">count</span><span class="p">,</span> <span class="n">_type</span><span class="o">=</span><span class="n">_type</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span>
            <span class="k">yield from</span> <span class="n">data</span>

    <span class="k">def</span> <span class="nf">sscan</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span>
        <span class="n">cursor</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">match</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">PatternT</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">count</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Incrementally return lists of elements in a set. Also return a cursor</span>
<span class="sd">        indicating the scan position.</span>

<span class="sd">        ``match`` allows for filtering the keys by pattern</span>

<span class="sd">        ``count`` allows for hint the minimum number of returns</span>

<span class="sd">        For more information see https://redis.io/commands/sscan</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pieces</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">EncodableT</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span><span class="p">,</span> <span class="n">cursor</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">match</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="sa">b</span><span class="s2">&quot;MATCH&quot;</span><span class="p">,</span> <span class="n">match</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">count</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="sa">b</span><span class="s2">&quot;COUNT&quot;</span><span class="p">,</span> <span class="n">count</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;SSCAN&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">pieces</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">sscan_iter</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span>
        <span class="n">match</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">PatternT</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">count</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make an iterator using the SSCAN command so that the client doesn&#39;t</span>
<span class="sd">        need to remember the cursor position.</span>

<span class="sd">        ``match`` allows for filtering the keys by pattern</span>

<span class="sd">        ``count`` allows for hint the minimum number of returns</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cursor</span> <span class="o">=</span> <span class="s2">&quot;0&quot;</span>
        <span class="k">while</span> <span class="n">cursor</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">cursor</span><span class="p">,</span> <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sscan</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">cursor</span><span class="o">=</span><span class="n">cursor</span><span class="p">,</span> <span class="n">match</span><span class="o">=</span><span class="n">match</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="n">count</span><span class="p">)</span>
            <span class="k">yield from</span> <span class="n">data</span>

    <span class="k">def</span> <span class="nf">hscan</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span>
        <span class="n">cursor</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">match</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">PatternT</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">count</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">no_values</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Incrementally return key/value slices in a hash. Also return a cursor</span>
<span class="sd">        indicating the scan position.</span>

<span class="sd">        ``match`` allows for filtering the keys by pattern</span>

<span class="sd">        ``count`` allows for hint the minimum number of returns</span>

<span class="sd">        ``no_values`` indicates to return only the keys, without values.</span>

<span class="sd">        For more information see https://redis.io/commands/hscan</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pieces</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">EncodableT</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span><span class="p">,</span> <span class="n">cursor</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">match</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="sa">b</span><span class="s2">&quot;MATCH&quot;</span><span class="p">,</span> <span class="n">match</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">count</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="sa">b</span><span class="s2">&quot;COUNT&quot;</span><span class="p">,</span> <span class="n">count</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">no_values</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="sa">b</span><span class="s2">&quot;NOVALUES&quot;</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;HSCAN&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">pieces</span><span class="p">,</span> <span class="n">no_values</span><span class="o">=</span><span class="n">no_values</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">hscan_iter</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">match</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">PatternT</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">count</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">no_values</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make an iterator using the HSCAN command so that the client doesn&#39;t</span>
<span class="sd">        need to remember the cursor position.</span>

<span class="sd">        ``match`` allows for filtering the keys by pattern</span>

<span class="sd">        ``count`` allows for hint the minimum number of returns</span>

<span class="sd">        ``no_values`` indicates to return only the keys, without values</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cursor</span> <span class="o">=</span> <span class="s2">&quot;0&quot;</span>
        <span class="k">while</span> <span class="n">cursor</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">cursor</span><span class="p">,</span> <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hscan</span><span class="p">(</span>
                <span class="n">name</span><span class="p">,</span> <span class="n">cursor</span><span class="o">=</span><span class="n">cursor</span><span class="p">,</span> <span class="n">match</span><span class="o">=</span><span class="n">match</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="n">count</span><span class="p">,</span> <span class="n">no_values</span><span class="o">=</span><span class="n">no_values</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">no_values</span><span class="p">:</span>
                <span class="k">yield from</span> <span class="n">data</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">yield from</span> <span class="n">data</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">zscan</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span>
        <span class="n">cursor</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">match</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">PatternT</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">count</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">score_cast_func</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">type</span><span class="p">,</span> <span class="n">Callable</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Incrementally return lists of elements in a sorted set. Also return a</span>
<span class="sd">        cursor indicating the scan position.</span>

<span class="sd">        ``match`` allows for filtering the keys by pattern</span>

<span class="sd">        ``count`` allows for hint the minimum number of returns</span>

<span class="sd">        ``score_cast_func`` a callable used to cast the score return value</span>

<span class="sd">        For more information see https://redis.io/commands/zscan</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pieces</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span><span class="p">,</span> <span class="n">cursor</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">match</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="sa">b</span><span class="s2">&quot;MATCH&quot;</span><span class="p">,</span> <span class="n">match</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">count</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="sa">b</span><span class="s2">&quot;COUNT&quot;</span><span class="p">,</span> <span class="n">count</span><span class="p">])</span>
        <span class="n">options</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;score_cast_func&quot;</span><span class="p">:</span> <span class="n">score_cast_func</span><span class="p">}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;ZSCAN&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">pieces</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">zscan_iter</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span>
        <span class="n">match</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">PatternT</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">count</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">score_cast_func</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">type</span><span class="p">,</span> <span class="n">Callable</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make an iterator using the ZSCAN command so that the client doesn&#39;t</span>
<span class="sd">        need to remember the cursor position.</span>

<span class="sd">        ``match`` allows for filtering the keys by pattern</span>

<span class="sd">        ``count`` allows for hint the minimum number of returns</span>

<span class="sd">        ``score_cast_func`` a callable used to cast the score return value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cursor</span> <span class="o">=</span> <span class="s2">&quot;0&quot;</span>
        <span class="k">while</span> <span class="n">cursor</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">cursor</span><span class="p">,</span> <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zscan</span><span class="p">(</span>
                <span class="n">name</span><span class="p">,</span>
                <span class="n">cursor</span><span class="o">=</span><span class="n">cursor</span><span class="p">,</span>
                <span class="n">match</span><span class="o">=</span><span class="n">match</span><span class="p">,</span>
                <span class="n">count</span><span class="o">=</span><span class="n">count</span><span class="p">,</span>
                <span class="n">score_cast_func</span><span class="o">=</span><span class="n">score_cast_func</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">yield from</span> <span class="n">data</span>


<span class="k">class</span> <span class="nc">AsyncScanCommands</span><span class="p">(</span><span class="n">ScanCommands</span><span class="p">):</span>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">scan_iter</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">match</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">PatternT</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">count</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">_type</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AsyncIterator</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make an iterator using the SCAN command so that the client doesn&#39;t</span>
<span class="sd">        need to remember the cursor position.</span>

<span class="sd">        ``match`` allows for filtering the keys by pattern</span>

<span class="sd">        ``count`` provides a hint to Redis about the number of keys to</span>
<span class="sd">            return per batch.</span>

<span class="sd">        ``_type`` filters the returned values by a particular Redis type.</span>
<span class="sd">            Stock Redis instances allow for the following types:</span>
<span class="sd">            HASH, LIST, SET, STREAM, STRING, ZSET</span>
<span class="sd">            Additionally, Redis modules can expose other types as well.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cursor</span> <span class="o">=</span> <span class="s2">&quot;0&quot;</span>
        <span class="k">while</span> <span class="n">cursor</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">cursor</span><span class="p">,</span> <span class="n">data</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">scan</span><span class="p">(</span>
                <span class="n">cursor</span><span class="o">=</span><span class="n">cursor</span><span class="p">,</span> <span class="n">match</span><span class="o">=</span><span class="n">match</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="n">count</span><span class="p">,</span> <span class="n">_type</span><span class="o">=</span><span class="n">_type</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">d</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">sscan_iter</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span>
        <span class="n">match</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">PatternT</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">count</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AsyncIterator</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make an iterator using the SSCAN command so that the client doesn&#39;t</span>
<span class="sd">        need to remember the cursor position.</span>

<span class="sd">        ``match`` allows for filtering the keys by pattern</span>

<span class="sd">        ``count`` allows for hint the minimum number of returns</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cursor</span> <span class="o">=</span> <span class="s2">&quot;0&quot;</span>
        <span class="k">while</span> <span class="n">cursor</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">cursor</span><span class="p">,</span> <span class="n">data</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">sscan</span><span class="p">(</span>
                <span class="n">name</span><span class="p">,</span> <span class="n">cursor</span><span class="o">=</span><span class="n">cursor</span><span class="p">,</span> <span class="n">match</span><span class="o">=</span><span class="n">match</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="n">count</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">d</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">hscan_iter</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">match</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">PatternT</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">count</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">no_values</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AsyncIterator</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make an iterator using the HSCAN command so that the client doesn&#39;t</span>
<span class="sd">        need to remember the cursor position.</span>

<span class="sd">        ``match`` allows for filtering the keys by pattern</span>

<span class="sd">        ``count`` allows for hint the minimum number of returns</span>

<span class="sd">        ``no_values`` indicates to return only the keys, without values</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cursor</span> <span class="o">=</span> <span class="s2">&quot;0&quot;</span>
        <span class="k">while</span> <span class="n">cursor</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">cursor</span><span class="p">,</span> <span class="n">data</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">hscan</span><span class="p">(</span>
                <span class="n">name</span><span class="p">,</span> <span class="n">cursor</span><span class="o">=</span><span class="n">cursor</span><span class="p">,</span> <span class="n">match</span><span class="o">=</span><span class="n">match</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="n">count</span><span class="p">,</span> <span class="n">no_values</span><span class="o">=</span><span class="n">no_values</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">no_values</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">it</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">yield</span> <span class="n">it</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">zscan_iter</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span>
        <span class="n">match</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">PatternT</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">count</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">score_cast_func</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">type</span><span class="p">,</span> <span class="n">Callable</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AsyncIterator</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make an iterator using the ZSCAN command so that the client doesn&#39;t</span>
<span class="sd">        need to remember the cursor position.</span>

<span class="sd">        ``match`` allows for filtering the keys by pattern</span>

<span class="sd">        ``count`` allows for hint the minimum number of returns</span>

<span class="sd">        ``score_cast_func`` a callable used to cast the score return value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cursor</span> <span class="o">=</span> <span class="s2">&quot;0&quot;</span>
        <span class="k">while</span> <span class="n">cursor</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">cursor</span><span class="p">,</span> <span class="n">data</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">zscan</span><span class="p">(</span>
                <span class="n">name</span><span class="p">,</span>
                <span class="n">cursor</span><span class="o">=</span><span class="n">cursor</span><span class="p">,</span>
                <span class="n">match</span><span class="o">=</span><span class="n">match</span><span class="p">,</span>
                <span class="n">count</span><span class="o">=</span><span class="n">count</span><span class="p">,</span>
                <span class="n">score_cast_func</span><span class="o">=</span><span class="n">score_cast_func</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">d</span>


<span class="k">class</span> <span class="nc">SetCommands</span><span class="p">(</span><span class="n">CommandsProtocol</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Redis commands for Set data type.</span>
<span class="sd">    see: https://redis.io/topics/data-types#sets</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">sadd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">*</span><span class="n">values</span><span class="p">:</span> <span class="n">FieldT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Awaitable</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add ``value(s)`` to set ``name``</span>

<span class="sd">        For more information see https://redis.io/commands/sadd</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;SADD&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="n">values</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">scard</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Awaitable</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of elements in set ``name``</span>

<span class="sd">        For more information see https://redis.io/commands/scard</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;SCARD&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">sdiff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keys</span><span class="p">:</span> <span class="n">List</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">List</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Awaitable</span><span class="p">[</span><span class="nb">list</span><span class="p">],</span> <span class="nb">list</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the difference of sets specified by ``keys``</span>

<span class="sd">        For more information see https://redis.io/commands/sdiff</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">list_or_args</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;SDIFF&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">sdiffstore</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">dest</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">keys</span><span class="p">:</span> <span class="n">List</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">List</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Awaitable</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Store the difference of sets specified by ``keys`` into a new</span>
<span class="sd">        set named ``dest``.  Returns the number of keys in the new set.</span>

<span class="sd">        For more information see https://redis.io/commands/sdiffstore</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">list_or_args</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;SDIFFSTORE&quot;</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">sinter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keys</span><span class="p">:</span> <span class="n">List</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">List</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Awaitable</span><span class="p">[</span><span class="nb">list</span><span class="p">],</span> <span class="nb">list</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the intersection of sets specified by ``keys``</span>

<span class="sd">        For more information see https://redis.io/commands/sinter</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">list_or_args</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;SINTER&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">sintercard</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">numkeys</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">keys</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">limit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Awaitable</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the cardinality of the intersect of multiple sets specified by ``keys``.</span>

<span class="sd">        When LIMIT provided (defaults to 0 and means unlimited), if the intersection</span>
<span class="sd">        cardinality reaches limit partway through the computation, the algorithm will</span>
<span class="sd">        exit and yield limit as the cardinality</span>

<span class="sd">        For more information see https://redis.io/commands/sintercard</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">numkeys</span><span class="p">,</span> <span class="o">*</span><span class="n">keys</span><span class="p">,</span> <span class="s2">&quot;LIMIT&quot;</span><span class="p">,</span> <span class="n">limit</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;SINTERCARD&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="n">keys</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">sinterstore</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">dest</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">keys</span><span class="p">:</span> <span class="n">List</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">List</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Awaitable</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Store the intersection of sets specified by ``keys`` into a new</span>
<span class="sd">        set named ``dest``.  Returns the number of keys in the new set.</span>

<span class="sd">        For more information see https://redis.io/commands/sinterstore</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">list_or_args</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;SINTERSTORE&quot;</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">sismember</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Awaitable</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Literal</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Literal</span><span class="p">[</span><span class="mi">1</span><span class="p">]]],</span> <span class="n">Union</span><span class="p">[</span><span class="n">Literal</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Literal</span><span class="p">[</span><span class="mi">1</span><span class="p">]]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether ``value`` is a member of set ``name``:</span>
<span class="sd">        - 1 if the value is a member of the set.</span>
<span class="sd">        - 0 if the value is not a member of the set or if key does not exist.</span>

<span class="sd">        For more information see https://redis.io/commands/sismember</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;SISMEMBER&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">smembers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Awaitable</span><span class="p">[</span><span class="n">Set</span><span class="p">],</span> <span class="n">Set</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return all members of the set ``name``</span>

<span class="sd">        For more information see https://redis.io/commands/smembers</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;SMEMBERS&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">smismember</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="n">List</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">List</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span>
        <span class="n">Awaitable</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Literal</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Literal</span><span class="p">[</span><span class="mi">1</span><span class="p">]]]],</span>
        <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Literal</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Literal</span><span class="p">[</span><span class="mi">1</span><span class="p">]]],</span>
    <span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether each value in ``values`` is a member of the set ``name``</span>
<span class="sd">        as a list of ``int`` in the order of ``values``:</span>
<span class="sd">        - 1 if the value is a member of the set.</span>
<span class="sd">        - 0 if the value is not a member of the set or if key does not exist.</span>

<span class="sd">        For more information see https://redis.io/commands/smismember</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">list_or_args</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;SMISMEMBER&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">smove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dst</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Awaitable</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="nb">bool</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Move ``value`` from set ``src`` to set ``dst`` atomically</span>

<span class="sd">        For more information see https://redis.io/commands/smove</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;SMOVE&quot;</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">spop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">count</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove and return a random member of set ``name``</span>

<span class="sd">        For more information see https://redis.io/commands/spop</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">count</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="ow">or</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;SPOP&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">srandmember</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If ``number`` is None, returns a random member of set ``name``.</span>

<span class="sd">        If ``number`` is supplied, returns a list of ``number`` random</span>
<span class="sd">        members of set ``name``. Note this is only available when running</span>
<span class="sd">        Redis 2.6+.</span>

<span class="sd">        For more information see https://redis.io/commands/srandmember</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">number</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">[</span><span class="n">number</span><span class="p">]</span> <span class="ow">or</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;SRANDMEMBER&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">srem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">*</span><span class="n">values</span><span class="p">:</span> <span class="n">FieldT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Awaitable</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove ``values`` from set ``name``</span>

<span class="sd">        For more information see https://redis.io/commands/srem</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;SREM&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="n">values</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">sunion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keys</span><span class="p">:</span> <span class="n">List</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">List</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Awaitable</span><span class="p">[</span><span class="n">List</span><span class="p">],</span> <span class="n">List</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the union of sets specified by ``keys``</span>

<span class="sd">        For more information see https://redis.io/commands/sunion</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">list_or_args</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;SUNION&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">sunionstore</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">dest</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">keys</span><span class="p">:</span> <span class="n">List</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">List</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Awaitable</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Store the union of sets specified by ``keys`` into a new</span>
<span class="sd">        set named ``dest``.  Returns the number of keys in the new set.</span>

<span class="sd">        For more information see https://redis.io/commands/sunionstore</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">list_or_args</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;SUNIONSTORE&quot;</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


<span class="n">AsyncSetCommands</span> <span class="o">=</span> <span class="n">SetCommands</span>


<span class="k">class</span> <span class="nc">StreamCommands</span><span class="p">(</span><span class="n">CommandsProtocol</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Redis commands for Stream data type.</span>
<span class="sd">    see: https://redis.io/topics/streams-intro</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">xack</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span> <span class="n">groupname</span><span class="p">:</span> <span class="n">GroupT</span><span class="p">,</span> <span class="o">*</span><span class="n">ids</span><span class="p">:</span> <span class="n">StreamIdT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Acknowledges the successful processing of one or more messages.</span>

<span class="sd">        Args:</span>
<span class="sd">            name: name of the stream.</span>
<span class="sd">            groupname: name of the consumer group.</span>
<span class="sd">            *ids: message ids to acknowledge.</span>

<span class="sd">        For more information see https://redis.io/commands/xack</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;XACK&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">groupname</span><span class="p">,</span> <span class="o">*</span><span class="n">ids</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">xadd</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span>
        <span class="n">fields</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">FieldT</span><span class="p">,</span> <span class="n">EncodableT</span><span class="p">],</span>
        <span class="nb">id</span><span class="p">:</span> <span class="n">StreamIdT</span> <span class="o">=</span> <span class="s2">&quot;*&quot;</span><span class="p">,</span>
        <span class="n">maxlen</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">approximate</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">nomkstream</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">minid</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">StreamIdT</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">limit</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add to a stream.</span>
<span class="sd">        name: name of the stream</span>
<span class="sd">        fields: dict of field/value pairs to insert into the stream</span>
<span class="sd">        id: Location to insert this record. By default it is appended.</span>
<span class="sd">        maxlen: truncate old stream members beyond this size.</span>
<span class="sd">        Can&#39;t be specified with minid.</span>
<span class="sd">        approximate: actual stream length may be slightly more than maxlen</span>
<span class="sd">        nomkstream: When set to true, do not make a stream</span>
<span class="sd">        minid: the minimum id in the stream to query.</span>
<span class="sd">        Can&#39;t be specified with maxlen.</span>
<span class="sd">        limit: specifies the maximum number of entries to retrieve</span>

<span class="sd">        For more information see https://redis.io/commands/xadd</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pieces</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">EncodableT</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">maxlen</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">minid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span><span class="s2">&quot;Only one of ```maxlen``` or ```minid``` may be specified&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">maxlen</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">maxlen</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="n">maxlen</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span><span class="s2">&quot;XADD maxlen must be non-negative integer&quot;</span><span class="p">)</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;MAXLEN&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">approximate</span><span class="p">:</span>
                <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;~&quot;</span><span class="p">)</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">maxlen</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">minid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;MINID&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">approximate</span><span class="p">:</span>
                <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;~&quot;</span><span class="p">)</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">minid</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">limit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="sa">b</span><span class="s2">&quot;LIMIT&quot;</span><span class="p">,</span> <span class="n">limit</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">nomkstream</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;NOMKSTREAM&quot;</span><span class="p">)</span>
        <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fields</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">fields</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span><span class="s2">&quot;XADD fields must be a non-empty dict&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">fields</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pair</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;XADD&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="n">pieces</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">xautoclaim</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span>
        <span class="n">groupname</span><span class="p">:</span> <span class="n">GroupT</span><span class="p">,</span>
        <span class="n">consumername</span><span class="p">:</span> <span class="n">ConsumerT</span><span class="p">,</span>
        <span class="n">min_idle_time</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">start_id</span><span class="p">:</span> <span class="n">StreamIdT</span> <span class="o">=</span> <span class="s2">&quot;0-0&quot;</span><span class="p">,</span>
        <span class="n">count</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">justid</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transfers ownership of pending stream entries that match the specified</span>
<span class="sd">        criteria. Conceptually, equivalent to calling XPENDING and then XCLAIM,</span>
<span class="sd">        but provides a more straightforward way to deal with message delivery</span>
<span class="sd">        failures via SCAN-like semantics.</span>
<span class="sd">        name: name of the stream.</span>
<span class="sd">        groupname: name of the consumer group.</span>
<span class="sd">        consumername: name of a consumer that claims the message.</span>
<span class="sd">        min_idle_time: filter messages that were idle less than this amount of</span>
<span class="sd">        milliseconds.</span>
<span class="sd">        start_id: filter messages with equal or greater ID.</span>
<span class="sd">        count: optional integer, upper limit of the number of entries that the</span>
<span class="sd">        command attempts to claim. Set to 100 by default.</span>
<span class="sd">        justid: optional boolean, false by default. Return just an array of IDs</span>
<span class="sd">        of messages successfully claimed, without returning the actual message</span>

<span class="sd">        For more information see https://redis.io/commands/xautoclaim</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">min_idle_time</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span>
                    <span class="s2">&quot;XAUTOCLAIM min_idle_time must be a nonnegative integer&quot;</span>
                <span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">pieces</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span><span class="p">,</span> <span class="n">groupname</span><span class="p">,</span> <span class="n">consumername</span><span class="p">,</span> <span class="n">min_idle_time</span><span class="p">,</span> <span class="n">start_id</span><span class="p">]</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">count</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span><span class="s2">&quot;XPENDING count must be a integer &gt;= 0&quot;</span><span class="p">)</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="sa">b</span><span class="s2">&quot;COUNT&quot;</span><span class="p">,</span> <span class="n">count</span><span class="p">])</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">if</span> <span class="n">justid</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;JUSTID&quot;</span><span class="p">)</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;parse_justid&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;XAUTOCLAIM&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">pieces</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">xclaim</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span>
        <span class="n">groupname</span><span class="p">:</span> <span class="n">GroupT</span><span class="p">,</span>
        <span class="n">consumername</span><span class="p">:</span> <span class="n">ConsumerT</span><span class="p">,</span>
        <span class="n">min_idle_time</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">message_ids</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">StreamIdT</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">StreamIdT</span><span class="p">]],</span>
        <span class="n">idle</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">time</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">retrycount</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">force</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">justid</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Changes the ownership of a pending message.</span>

<span class="sd">        name: name of the stream.</span>

<span class="sd">        groupname: name of the consumer group.</span>

<span class="sd">        consumername: name of a consumer that claims the message.</span>

<span class="sd">        min_idle_time: filter messages that were idle less than this amount of</span>
<span class="sd">        milliseconds</span>

<span class="sd">        message_ids: non-empty list or tuple of message IDs to claim</span>

<span class="sd">        idle: optional. Set the idle time (last time it was delivered) of the</span>
<span class="sd">        message in ms</span>

<span class="sd">        time: optional integer. This is the same as idle but instead of a</span>
<span class="sd">        relative amount of milliseconds, it sets the idle time to a specific</span>
<span class="sd">        Unix time (in milliseconds).</span>

<span class="sd">        retrycount: optional integer. set the retry counter to the specified</span>
<span class="sd">        value. This counter is incremented every time a message is delivered</span>
<span class="sd">        again.</span>

<span class="sd">        force: optional boolean, false by default. Creates the pending message</span>
<span class="sd">        entry in the PEL even if certain specified IDs are not already in the</span>
<span class="sd">        PEL assigned to a different client.</span>

<span class="sd">        justid: optional boolean, false by default. Return just an array of IDs</span>
<span class="sd">        of messages successfully claimed, without returning the actual message</span>

<span class="sd">        For more information see https://redis.io/commands/xclaim</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">min_idle_time</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="n">min_idle_time</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span><span class="s2">&quot;XCLAIM min_idle_time must be a non negative integer&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">message_ids</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">message_ids</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span>
                <span class="s2">&quot;XCLAIM message_ids must be a non empty list or &quot;</span>
                <span class="s2">&quot;tuple of message IDs to claim&quot;</span>
            <span class="p">)</span>

        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">pieces</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">EncodableT</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span><span class="p">,</span> <span class="n">groupname</span><span class="p">,</span> <span class="n">consumername</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">min_idle_time</span><span class="p">)]</span>
        <span class="n">pieces</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">message_ids</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">idle</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">idle</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span><span class="s2">&quot;XCLAIM idle must be an integer&quot;</span><span class="p">)</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">extend</span><span class="p">((</span><span class="sa">b</span><span class="s2">&quot;IDLE&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">idle</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">time</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span><span class="s2">&quot;XCLAIM time must be an integer&quot;</span><span class="p">)</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">extend</span><span class="p">((</span><span class="sa">b</span><span class="s2">&quot;TIME&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">time</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">retrycount</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">retrycount</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span><span class="s2">&quot;XCLAIM retrycount must be an integer&quot;</span><span class="p">)</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">extend</span><span class="p">((</span><span class="sa">b</span><span class="s2">&quot;RETRYCOUNT&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">retrycount</span><span class="p">)))</span>

        <span class="k">if</span> <span class="n">force</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">force</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span><span class="s2">&quot;XCLAIM force must be a boolean&quot;</span><span class="p">)</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;FORCE&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">justid</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">justid</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span><span class="s2">&quot;XCLAIM justid must be a boolean&quot;</span><span class="p">)</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;JUSTID&quot;</span><span class="p">)</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;parse_justid&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;XCLAIM&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">pieces</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">xdel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span> <span class="o">*</span><span class="n">ids</span><span class="p">:</span> <span class="n">StreamIdT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Deletes one or more messages from a stream.</span>

<span class="sd">        Args:</span>
<span class="sd">            name: name of the stream.</span>
<span class="sd">            *ids: message ids to delete.</span>

<span class="sd">        For more information see https://redis.io/commands/xdel</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;XDEL&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="n">ids</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">xgroup_create</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span>
        <span class="n">groupname</span><span class="p">:</span> <span class="n">GroupT</span><span class="p">,</span>
        <span class="nb">id</span><span class="p">:</span> <span class="n">StreamIdT</span> <span class="o">=</span> <span class="s2">&quot;$&quot;</span><span class="p">,</span>
        <span class="n">mkstream</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">entries_read</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new consumer group associated with a stream.</span>
<span class="sd">        name: name of the stream.</span>
<span class="sd">        groupname: name of the consumer group.</span>
<span class="sd">        id: ID of the last item in the stream to consider already delivered.</span>

<span class="sd">        For more information see https://redis.io/commands/xgroup-create</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pieces</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">EncodableT</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;XGROUP CREATE&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">groupname</span><span class="p">,</span> <span class="nb">id</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">mkstream</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;MKSTREAM&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">entries_read</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s2">&quot;ENTRIESREAD&quot;</span><span class="p">,</span> <span class="n">entries_read</span><span class="p">])</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="o">*</span><span class="n">pieces</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">xgroup_delconsumer</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span> <span class="n">groupname</span><span class="p">:</span> <span class="n">GroupT</span><span class="p">,</span> <span class="n">consumername</span><span class="p">:</span> <span class="n">ConsumerT</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove a specific consumer from a consumer group.</span>
<span class="sd">        Returns the number of pending messages that the consumer had before it</span>
<span class="sd">        was deleted.</span>
<span class="sd">        name: name of the stream.</span>
<span class="sd">        groupname: name of the consumer group.</span>
<span class="sd">        consumername: name of consumer to delete</span>

<span class="sd">        For more information see https://redis.io/commands/xgroup-delconsumer</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;XGROUP DELCONSUMER&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">groupname</span><span class="p">,</span> <span class="n">consumername</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">xgroup_destroy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span> <span class="n">groupname</span><span class="p">:</span> <span class="n">GroupT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Destroy a consumer group.</span>
<span class="sd">        name: name of the stream.</span>
<span class="sd">        groupname: name of the consumer group.</span>

<span class="sd">        For more information see https://redis.io/commands/xgroup-destroy</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;XGROUP DESTROY&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">groupname</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">xgroup_createconsumer</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span> <span class="n">groupname</span><span class="p">:</span> <span class="n">GroupT</span><span class="p">,</span> <span class="n">consumername</span><span class="p">:</span> <span class="n">ConsumerT</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Consumers in a consumer group are auto-created every time a new</span>
<span class="sd">        consumer name is mentioned by some command.</span>
<span class="sd">        They can be explicitly created by using this command.</span>
<span class="sd">        name: name of the stream.</span>
<span class="sd">        groupname: name of the consumer group.</span>
<span class="sd">        consumername: name of consumer to create.</span>

<span class="sd">        See: https://redis.io/commands/xgroup-createconsumer</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span>
            <span class="s2">&quot;XGROUP CREATECONSUMER&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">groupname</span><span class="p">,</span> <span class="n">consumername</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">xgroup_setid</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span>
        <span class="n">groupname</span><span class="p">:</span> <span class="n">GroupT</span><span class="p">,</span>
        <span class="nb">id</span><span class="p">:</span> <span class="n">StreamIdT</span><span class="p">,</span>
        <span class="n">entries_read</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the consumer group last delivered ID to something else.</span>
<span class="sd">        name: name of the stream.</span>
<span class="sd">        groupname: name of the consumer group.</span>
<span class="sd">        id: ID of the last item in the stream to consider already delivered.</span>

<span class="sd">        For more information see https://redis.io/commands/xgroup-setid</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pieces</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span><span class="p">,</span> <span class="n">groupname</span><span class="p">,</span> <span class="nb">id</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">entries_read</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s2">&quot;ENTRIESREAD&quot;</span><span class="p">,</span> <span class="n">entries_read</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;XGROUP SETID&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">pieces</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">xinfo_consumers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span> <span class="n">groupname</span><span class="p">:</span> <span class="n">GroupT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns general information about the consumers in the group.</span>
<span class="sd">        name: name of the stream.</span>
<span class="sd">        groupname: name of the consumer group.</span>

<span class="sd">        For more information see https://redis.io/commands/xinfo-consumers</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;XINFO CONSUMERS&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">groupname</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">xinfo_groups</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns general information about the consumer groups of the stream.</span>
<span class="sd">        name: name of the stream.</span>

<span class="sd">        For more information see https://redis.io/commands/xinfo-groups</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;XINFO GROUPS&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">xinfo_stream</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span> <span class="n">full</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns general information about the stream.</span>
<span class="sd">        name: name of the stream.</span>
<span class="sd">        full: optional boolean, false by default. Return full summary</span>

<span class="sd">        For more information see https://redis.io/commands/xinfo-stream</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pieces</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="n">options</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">full</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;FULL&quot;</span><span class="p">)</span>
            <span class="n">options</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;full&quot;</span><span class="p">:</span> <span class="n">full</span><span class="p">}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;XINFO STREAM&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">pieces</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">xlen</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of elements in a given stream.</span>

<span class="sd">        For more information see https://redis.io/commands/xlen</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;XLEN&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">xpending</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span> <span class="n">groupname</span><span class="p">:</span> <span class="n">GroupT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns information about pending messages of a group.</span>
<span class="sd">        name: name of the stream.</span>
<span class="sd">        groupname: name of the consumer group.</span>

<span class="sd">        For more information see https://redis.io/commands/xpending</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;XPENDING&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">groupname</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">xpending_range</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span>
        <span class="n">groupname</span><span class="p">:</span> <span class="n">GroupT</span><span class="p">,</span>
        <span class="nb">min</span><span class="p">:</span> <span class="n">StreamIdT</span><span class="p">,</span>
        <span class="nb">max</span><span class="p">:</span> <span class="n">StreamIdT</span><span class="p">,</span>
        <span class="n">count</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">consumername</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ConsumerT</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">idle</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns information about pending messages, in a range.</span>

<span class="sd">        name: name of the stream.</span>
<span class="sd">        groupname: name of the consumer group.</span>
<span class="sd">        idle: available from  version 6.2. filter entries by their</span>
<span class="sd">        idle-time, given in milliseconds (optional).</span>
<span class="sd">        min: minimum stream ID.</span>
<span class="sd">        max: maximum stream ID.</span>
<span class="sd">        count: number of messages to return</span>
<span class="sd">        consumername: name of a consumer to filter by (optional).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">{</span><span class="nb">min</span><span class="p">,</span> <span class="nb">max</span><span class="p">,</span> <span class="n">count</span><span class="p">}</span> <span class="o">==</span> <span class="p">{</span><span class="kc">None</span><span class="p">}:</span>
            <span class="k">if</span> <span class="n">idle</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">consumername</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span>
                    <span class="s2">&quot;if XPENDING is provided with idle time&quot;</span>
                    <span class="s2">&quot; or consumername, it must be provided&quot;</span>
                    <span class="s2">&quot; with min, max and count parameters&quot;</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">xpending</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">groupname</span><span class="p">)</span>

        <span class="n">pieces</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span><span class="p">,</span> <span class="n">groupname</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">min</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">max</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">count</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span>
                <span class="s2">&quot;XPENDING must be provided with min, max &quot;</span>
                <span class="s2">&quot;and count parameters, or none of them.&quot;</span>
            <span class="p">)</span>
        <span class="c1"># idle</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">idle</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span><span class="s2">&quot;XPENDING idle must be a integer &gt;= 0&quot;</span><span class="p">)</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s2">&quot;IDLE&quot;</span><span class="p">,</span> <span class="n">idle</span><span class="p">])</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="c1"># count</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">count</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span><span class="s2">&quot;XPENDING count must be a integer &gt;= 0&quot;</span><span class="p">)</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="nb">min</span><span class="p">,</span> <span class="nb">max</span><span class="p">,</span> <span class="n">count</span><span class="p">])</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="c1"># consumername</span>
        <span class="k">if</span> <span class="n">consumername</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">consumername</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;XPENDING&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">pieces</span><span class="p">,</span> <span class="n">parse_detail</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">xrange</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span>
        <span class="nb">min</span><span class="p">:</span> <span class="n">StreamIdT</span> <span class="o">=</span> <span class="s2">&quot;-&quot;</span><span class="p">,</span>
        <span class="nb">max</span><span class="p">:</span> <span class="n">StreamIdT</span> <span class="o">=</span> <span class="s2">&quot;+&quot;</span><span class="p">,</span>
        <span class="n">count</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read stream values within an interval.</span>

<span class="sd">        name: name of the stream.</span>

<span class="sd">        start: first stream ID. defaults to &#39;-&#39;,</span>
<span class="sd">               meaning the earliest available.</span>

<span class="sd">        finish: last stream ID. defaults to &#39;+&#39;,</span>
<span class="sd">                meaning the latest available.</span>

<span class="sd">        count: if set, only return this many items, beginning with the</span>
<span class="sd">               earliest available.</span>

<span class="sd">        For more information see https://redis.io/commands/xrange</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pieces</span> <span class="o">=</span> <span class="p">[</span><span class="nb">min</span><span class="p">,</span> <span class="nb">max</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">count</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span><span class="s2">&quot;XRANGE count must be a positive integer&quot;</span><span class="p">)</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;COUNT&quot;</span><span class="p">)</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">count</span><span class="p">))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;XRANGE&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="n">pieces</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">xread</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">streams</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">KeyT</span><span class="p">,</span> <span class="n">StreamIdT</span><span class="p">],</span>
        <span class="n">count</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">block</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Block and monitor multiple streams for new data.</span>

<span class="sd">        streams: a dict of stream names to stream IDs, where</span>
<span class="sd">                   IDs indicate the last ID already seen.</span>

<span class="sd">        count: if set, only return this many items, beginning with the</span>
<span class="sd">               earliest available.</span>

<span class="sd">        block: number of milliseconds to wait, if nothing already present.</span>

<span class="sd">        For more information see https://redis.io/commands/xread</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pieces</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">block</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="n">block</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span><span class="s2">&quot;XREAD block must be a non-negative integer&quot;</span><span class="p">)</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;BLOCK&quot;</span><span class="p">)</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">block</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">count</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span><span class="s2">&quot;XREAD count must be a positive integer&quot;</span><span class="p">)</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;COUNT&quot;</span><span class="p">)</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">count</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">streams</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">streams</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span><span class="s2">&quot;XREAD streams must be a non empty dict&quot;</span><span class="p">)</span>
        <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;STREAMS&quot;</span><span class="p">)</span>
        <span class="n">keys</span><span class="p">,</span> <span class="n">values</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">streams</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
        <span class="n">pieces</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span>
        <span class="n">pieces</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;XREAD&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">pieces</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="n">keys</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">xreadgroup</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">groupname</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">consumername</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">streams</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">KeyT</span><span class="p">,</span> <span class="n">StreamIdT</span><span class="p">],</span>
        <span class="n">count</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">block</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">noack</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read from a stream via a consumer group.</span>

<span class="sd">        groupname: name of the consumer group.</span>

<span class="sd">        consumername: name of the requesting consumer.</span>

<span class="sd">        streams: a dict of stream names to stream IDs, where</span>
<span class="sd">               IDs indicate the last ID already seen.</span>

<span class="sd">        count: if set, only return this many items, beginning with the</span>
<span class="sd">               earliest available.</span>

<span class="sd">        block: number of milliseconds to wait, if nothing already present.</span>
<span class="sd">        noack: do not add messages to the PEL</span>

<span class="sd">        For more information see https://redis.io/commands/xreadgroup</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pieces</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">EncodableT</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="sa">b</span><span class="s2">&quot;GROUP&quot;</span><span class="p">,</span> <span class="n">groupname</span><span class="p">,</span> <span class="n">consumername</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">count</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span><span class="s2">&quot;XREADGROUP count must be a positive integer&quot;</span><span class="p">)</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;COUNT&quot;</span><span class="p">)</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">count</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">block</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="n">block</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span><span class="s2">&quot;XREADGROUP block must be a non-negative integer&quot;</span><span class="p">)</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;BLOCK&quot;</span><span class="p">)</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">block</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">noack</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;NOACK&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">streams</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">streams</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span><span class="s2">&quot;XREADGROUP streams must be a non empty dict&quot;</span><span class="p">)</span>
        <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;STREAMS&quot;</span><span class="p">)</span>
        <span class="n">pieces</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">streams</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">pieces</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">streams</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;XREADGROUP&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">pieces</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">xrevrange</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span>
        <span class="nb">max</span><span class="p">:</span> <span class="n">StreamIdT</span> <span class="o">=</span> <span class="s2">&quot;+&quot;</span><span class="p">,</span>
        <span class="nb">min</span><span class="p">:</span> <span class="n">StreamIdT</span> <span class="o">=</span> <span class="s2">&quot;-&quot;</span><span class="p">,</span>
        <span class="n">count</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read stream values within an interval, in reverse order.</span>

<span class="sd">        name: name of the stream</span>

<span class="sd">        start: first stream ID. defaults to &#39;+&#39;,</span>
<span class="sd">               meaning the latest available.</span>

<span class="sd">        finish: last stream ID. defaults to &#39;-&#39;,</span>
<span class="sd">                meaning the earliest available.</span>

<span class="sd">        count: if set, only return this many items, beginning with the</span>
<span class="sd">               latest available.</span>

<span class="sd">        For more information see https://redis.io/commands/xrevrange</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pieces</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">EncodableT</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">max</span><span class="p">,</span> <span class="nb">min</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">count</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span><span class="s2">&quot;XREVRANGE count must be a positive integer&quot;</span><span class="p">)</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;COUNT&quot;</span><span class="p">)</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">count</span><span class="p">))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;XREVRANGE&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="n">pieces</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">xtrim</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span>
        <span class="n">maxlen</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">approximate</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">minid</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">StreamIdT</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">limit</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Trims old messages from a stream.</span>
<span class="sd">        name: name of the stream.</span>
<span class="sd">        maxlen: truncate old stream messages beyond this size</span>
<span class="sd">        Can&#39;t be specified with minid.</span>
<span class="sd">        approximate: actual stream length may be slightly more than maxlen</span>
<span class="sd">        minid: the minimum id in the stream to query</span>
<span class="sd">        Can&#39;t be specified with maxlen.</span>
<span class="sd">        limit: specifies the maximum number of entries to retrieve</span>

<span class="sd">        For more information see https://redis.io/commands/xtrim</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pieces</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">EncodableT</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">maxlen</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">minid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span><span class="s2">&quot;Only one of ``maxlen`` or ``minid`` may be specified&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">maxlen</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">minid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span><span class="s2">&quot;One of ``maxlen`` or ``minid`` must be specified&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">maxlen</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;MAXLEN&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">minid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;MINID&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">approximate</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;~&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">maxlen</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">maxlen</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">minid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">minid</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">limit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;LIMIT&quot;</span><span class="p">)</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">limit</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;XTRIM&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="n">pieces</span><span class="p">)</span>


<span class="n">AsyncStreamCommands</span> <span class="o">=</span> <span class="n">StreamCommands</span>


<span class="k">class</span> <span class="nc">SortedSetCommands</span><span class="p">(</span><span class="n">CommandsProtocol</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Redis commands for Sorted Sets data type.</span>
<span class="sd">    see: https://redis.io/topics/data-types-intro#redis-sorted-sets</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">zadd</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span>
        <span class="n">mapping</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">AnyKeyT</span><span class="p">,</span> <span class="n">EncodableT</span><span class="p">],</span>
        <span class="n">nx</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">xx</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">ch</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">incr</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">gt</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">lt</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set any number of element-name, score pairs to the key ``name``. Pairs</span>
<span class="sd">        are specified as a dict of element-names keys to score values.</span>

<span class="sd">        ``nx`` forces ZADD to only create new elements and not to update</span>
<span class="sd">        scores for elements that already exist.</span>

<span class="sd">        ``xx`` forces ZADD to only update scores of elements that already</span>
<span class="sd">        exist. New elements will not be added.</span>

<span class="sd">        ``ch`` modifies the return value to be the numbers of elements changed.</span>
<span class="sd">        Changed elements include new elements that were added and elements</span>
<span class="sd">        whose scores changed.</span>

<span class="sd">        ``incr`` modifies ZADD to behave like ZINCRBY. In this mode only a</span>
<span class="sd">        single element/score pair can be specified and the score is the amount</span>
<span class="sd">        the existing score will be incremented by. When using this mode the</span>
<span class="sd">        return value of ZADD will be the new score of the element.</span>

<span class="sd">        ``LT`` Only update existing elements if the new score is less than</span>
<span class="sd">        the current score. This flag doesn&#39;t prevent adding new elements.</span>

<span class="sd">        ``GT`` Only update existing elements if the new score is greater than</span>
<span class="sd">        the current score. This flag doesn&#39;t prevent adding new elements.</span>

<span class="sd">        The return value of ZADD varies based on the mode specified. With no</span>
<span class="sd">        options, ZADD returns the number of new elements added to the sorted</span>
<span class="sd">        set.</span>

<span class="sd">        ``NX``, ``LT``, and ``GT`` are mutually exclusive options.</span>

<span class="sd">        See: https://redis.io/commands/ZADD</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">mapping</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span><span class="s2">&quot;ZADD requires at least one element/score pair&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nx</span> <span class="ow">and</span> <span class="n">xx</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span><span class="s2">&quot;ZADD allows either &#39;nx&#39; or &#39;xx&#39;, not both&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">gt</span> <span class="ow">and</span> <span class="n">lt</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span><span class="s2">&quot;ZADD allows either &#39;gt&#39; or &#39;lt&#39;, not both&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">incr</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">mapping</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span>
                <span class="s2">&quot;ZADD option &#39;incr&#39; only works when passing a &quot;</span>
                <span class="s2">&quot;single element/score pair&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">nx</span> <span class="ow">and</span> <span class="p">(</span><span class="n">gt</span> <span class="ow">or</span> <span class="n">lt</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span><span class="s2">&quot;Only one of &#39;nx&#39;, &#39;lt&#39;, or &#39;gr&#39; may be defined.&quot;</span><span class="p">)</span>

        <span class="n">pieces</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">EncodableT</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">options</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">nx</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;NX&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">xx</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;XX&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ch</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;CH&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">incr</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;INCR&quot;</span><span class="p">)</span>
            <span class="n">options</span><span class="p">[</span><span class="s2">&quot;as_score&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">gt</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;GT&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">lt</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;LT&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">mapping</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;ZADD&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="n">pieces</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">zcard</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of elements in the sorted set ``name``</span>

<span class="sd">        For more information see https://redis.io/commands/zcard</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;ZCARD&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">zcount</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span> <span class="nb">min</span><span class="p">:</span> <span class="n">ZScoreBoundT</span><span class="p">,</span> <span class="nb">max</span><span class="p">:</span> <span class="n">ZScoreBoundT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of elements in the sorted set at key ``name`` with</span>
<span class="sd">        a score between ``min`` and ``max``.</span>

<span class="sd">        For more information see https://redis.io/commands/zcount</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;ZCOUNT&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="nb">min</span><span class="p">,</span> <span class="nb">max</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">zdiff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keys</span><span class="p">:</span> <span class="n">KeysT</span><span class="p">,</span> <span class="n">withscores</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the difference between the first and all successive input</span>
<span class="sd">        sorted sets provided in ``keys``.</span>

<span class="sd">        For more information see https://redis.io/commands/zdiff</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pieces</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">),</span> <span class="o">*</span><span class="n">keys</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">withscores</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;WITHSCORES&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;ZDIFF&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">pieces</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="n">keys</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">zdiffstore</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dest</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span> <span class="n">keys</span><span class="p">:</span> <span class="n">KeysT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the difference between the first and all successive input</span>
<span class="sd">        sorted sets provided in ``keys`` and stores the result in ``dest``.</span>

<span class="sd">        For more information see https://redis.io/commands/zdiffstore</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pieces</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">),</span> <span class="o">*</span><span class="n">keys</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;ZDIFFSTORE&quot;</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="o">*</span><span class="n">pieces</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">zincrby</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span> <span class="n">amount</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">EncodableT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Increment the score of ``value`` in sorted set ``name`` by ``amount``</span>

<span class="sd">        For more information see https://redis.io/commands/zincrby</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;ZINCRBY&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">amount</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">zinter</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">keys</span><span class="p">:</span> <span class="n">KeysT</span><span class="p">,</span> <span class="n">aggregate</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">withscores</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the intersect of multiple sorted sets specified by ``keys``.</span>
<span class="sd">        With the ``aggregate`` option, it is possible to specify how the</span>
<span class="sd">        results of the union are aggregated. This option defaults to SUM,</span>
<span class="sd">        where the score of an element is summed across the inputs where it</span>
<span class="sd">        exists. When this option is set to either MIN or MAX, the resulting</span>
<span class="sd">        set will contain the minimum or maximum score of an element across</span>
<span class="sd">        the inputs where it exists.</span>

<span class="sd">        For more information see https://redis.io/commands/zinter</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zaggregate</span><span class="p">(</span><span class="s2">&quot;ZINTER&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">keys</span><span class="p">,</span> <span class="n">aggregate</span><span class="p">,</span> <span class="n">withscores</span><span class="o">=</span><span class="n">withscores</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">zinterstore</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">dest</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span>
        <span class="n">keys</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">KeyT</span><span class="p">],</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">AnyKeyT</span><span class="p">,</span> <span class="nb">float</span><span class="p">]],</span>
        <span class="n">aggregate</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Intersect multiple sorted sets specified by ``keys`` into a new</span>
<span class="sd">        sorted set, ``dest``. Scores in the destination will be aggregated</span>
<span class="sd">        based on the ``aggregate``. This option defaults to SUM, where the</span>
<span class="sd">        score of an element is summed across the inputs where it exists.</span>
<span class="sd">        When this option is set to either MIN or MAX, the resulting set will</span>
<span class="sd">        contain the minimum or maximum score of an element across the inputs</span>
<span class="sd">        where it exists.</span>

<span class="sd">        For more information see https://redis.io/commands/zinterstore</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zaggregate</span><span class="p">(</span><span class="s2">&quot;ZINTERSTORE&quot;</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">keys</span><span class="p">,</span> <span class="n">aggregate</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">zintercard</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">numkeys</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">keys</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">limit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Awaitable</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the cardinality of the intersect of multiple sorted sets</span>
<span class="sd">        specified by ``keys``.</span>
<span class="sd">        When LIMIT provided (defaults to 0 and means unlimited), if the intersection</span>
<span class="sd">        cardinality reaches limit partway through the computation, the algorithm will</span>
<span class="sd">        exit and yield limit as the cardinality</span>

<span class="sd">        For more information see https://redis.io/commands/zintercard</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">numkeys</span><span class="p">,</span> <span class="o">*</span><span class="n">keys</span><span class="p">,</span> <span class="s2">&quot;LIMIT&quot;</span><span class="p">,</span> <span class="n">limit</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;ZINTERCARD&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="n">keys</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">zlexcount</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="nb">min</span><span class="p">,</span> <span class="nb">max</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of items in the sorted set ``name`` between the</span>
<span class="sd">        lexicographical range ``min`` and ``max``.</span>

<span class="sd">        For more information see https://redis.io/commands/zlexcount</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;ZLEXCOUNT&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="nb">min</span><span class="p">,</span> <span class="nb">max</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">zpopmax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span> <span class="n">count</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove and return up to ``count`` members with the highest scores</span>
<span class="sd">        from the sorted set ``name``.</span>

<span class="sd">        For more information see https://redis.io/commands/zpopmax</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">count</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="ow">or</span> <span class="p">[]</span>
        <span class="n">options</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;withscores&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;ZPOPMAX&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">zpopmin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span> <span class="n">count</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove and return up to ``count`` members with the lowest scores</span>
<span class="sd">        from the sorted set ``name``.</span>

<span class="sd">        For more information see https://redis.io/commands/zpopmin</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">count</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="ow">or</span> <span class="p">[]</span>
        <span class="n">options</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;withscores&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;ZPOPMIN&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">zrandmember</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span> <span class="n">count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">withscores</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a random element from the sorted set value stored at key.</span>

<span class="sd">        ``count`` if the argument is positive, return an array of distinct</span>
<span class="sd">        fields. If called with a negative count, the behavior changes and</span>
<span class="sd">        the command is allowed to return the same field multiple times.</span>
<span class="sd">        In this case, the number of returned fields is the absolute value</span>
<span class="sd">        of the specified count.</span>

<span class="sd">        ``withscores`` The optional WITHSCORES modifier changes the reply so it</span>
<span class="sd">        includes the respective scores of the randomly selected elements from</span>
<span class="sd">        the sorted set.</span>

<span class="sd">        For more information see https://redis.io/commands/zrandmember</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">params</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">count</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">count</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">withscores</span><span class="p">:</span>
            <span class="n">params</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;WITHSCORES&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;ZRANDMEMBER&quot;</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="o">*</span><span class="n">params</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">bzpopmax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keys</span><span class="p">:</span> <span class="n">KeysT</span><span class="p">,</span> <span class="n">timeout</span><span class="p">:</span> <span class="n">TimeoutSecT</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        ZPOPMAX a value off of the first non-empty sorted set</span>
<span class="sd">        named in the ``keys`` list.</span>

<span class="sd">        If none of the sorted sets in ``keys`` has a value to ZPOPMAX,</span>
<span class="sd">        then block for ``timeout`` seconds, or until a member gets added</span>
<span class="sd">        to one of the sorted sets.</span>

<span class="sd">        If timeout is 0, then block indefinitely.</span>

<span class="sd">        For more information see https://redis.io/commands/bzpopmax</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">timeout</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">timeout</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="n">list_or_args</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">timeout</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;BZPOPMAX&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">keys</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">bzpopmin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keys</span><span class="p">:</span> <span class="n">KeysT</span><span class="p">,</span> <span class="n">timeout</span><span class="p">:</span> <span class="n">TimeoutSecT</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        ZPOPMIN a value off of the first non-empty sorted set</span>
<span class="sd">        named in the ``keys`` list.</span>

<span class="sd">        If none of the sorted sets in ``keys`` has a value to ZPOPMIN,</span>
<span class="sd">        then block for ``timeout`` seconds, or until a member gets added</span>
<span class="sd">        to one of the sorted sets.</span>

<span class="sd">        If timeout is 0, then block indefinitely.</span>

<span class="sd">        For more information see https://redis.io/commands/bzpopmin</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">timeout</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">timeout</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">keys</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">EncodableT</span><span class="p">]</span> <span class="o">=</span> <span class="n">list_or_args</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">timeout</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;BZPOPMIN&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">keys</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">zmpop</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">num_keys</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">keys</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="nb">min</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="nb">max</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">count</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Awaitable</span><span class="p">[</span><span class="nb">list</span><span class="p">],</span> <span class="nb">list</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pop ``count`` values (default 1) off of the first non-empty sorted set</span>
<span class="sd">        named in the ``keys`` list.</span>
<span class="sd">        For more information see https://redis.io/commands/zmpop</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">num_keys</span><span class="p">]</span> <span class="o">+</span> <span class="n">keys</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">min</span> <span class="ow">and</span> <span class="nb">max</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">min</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">max</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">DataError</span>
        <span class="k">elif</span> <span class="nb">min</span><span class="p">:</span>
            <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;MIN&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;MAX&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">count</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">args</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s2">&quot;COUNT&quot;</span><span class="p">,</span> <span class="n">count</span><span class="p">])</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;ZMPOP&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">bzmpop</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">timeout</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">numkeys</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">keys</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="nb">min</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="nb">max</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">count</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pop ``count`` values (default 1) off of the first non-empty sorted set</span>
<span class="sd">        named in the ``keys`` list.</span>

<span class="sd">        If none of the sorted sets in ``keys`` has a value to pop,</span>
<span class="sd">        then block for ``timeout`` seconds, or until a member gets added</span>
<span class="sd">        to one of the sorted sets.</span>

<span class="sd">        If timeout is 0, then block indefinitely.</span>

<span class="sd">        For more information see https://redis.io/commands/bzmpop</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">timeout</span><span class="p">,</span> <span class="n">numkeys</span><span class="p">,</span> <span class="o">*</span><span class="n">keys</span><span class="p">]</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">min</span> <span class="ow">and</span> <span class="nb">max</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">min</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">max</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span><span class="s2">&quot;Either min or max, but not both must be set&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">min</span><span class="p">:</span>
            <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;MIN&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;MAX&quot;</span><span class="p">)</span>
        <span class="n">args</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s2">&quot;COUNT&quot;</span><span class="p">,</span> <span class="n">count</span><span class="p">])</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;BZMPOP&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_zrange</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">command</span><span class="p">,</span>
        <span class="n">dest</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">KeyT</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span>
        <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span>
        <span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">end</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">desc</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">byscore</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">bylex</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">withscores</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">score_cast_func</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">type</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">offset</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">num</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">byscore</span> <span class="ow">and</span> <span class="n">bylex</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span><span class="s2">&quot;``byscore`` and ``bylex`` can not be specified together.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">num</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">num</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">offset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span><span class="s2">&quot;``offset`` and ``num`` must both be specified.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bylex</span> <span class="ow">and</span> <span class="n">withscores</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span>
                <span class="s2">&quot;``withscores`` not supported in combination with ``bylex``.&quot;</span>
            <span class="p">)</span>
        <span class="n">pieces</span> <span class="o">=</span> <span class="p">[</span><span class="n">command</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">dest</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dest</span><span class="p">)</span>
        <span class="n">pieces</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">name</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">byscore</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;BYSCORE&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bylex</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;BYLEX&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">desc</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;REV&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">offset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">num</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s2">&quot;LIMIT&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">num</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">withscores</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;WITHSCORES&quot;</span><span class="p">)</span>
        <span class="n">options</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;withscores&quot;</span><span class="p">:</span> <span class="n">withscores</span><span class="p">,</span> <span class="s2">&quot;score_cast_func&quot;</span><span class="p">:</span> <span class="n">score_cast_func</span><span class="p">}</span>
        <span class="n">options</span><span class="p">[</span><span class="s2">&quot;keys&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="o">*</span><span class="n">pieces</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">zrange</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span>
        <span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">end</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">desc</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">withscores</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">score_cast_func</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">type</span><span class="p">,</span> <span class="n">Callable</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">byscore</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">bylex</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">offset</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">num</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a range of values from sorted set ``name`` between</span>
<span class="sd">        ``start`` and ``end`` sorted in ascending order.</span>

<span class="sd">        ``start`` and ``end`` can be negative, indicating the end of the range.</span>

<span class="sd">        ``desc`` a boolean indicating whether to sort the results in reversed</span>
<span class="sd">        order.</span>

<span class="sd">        ``withscores`` indicates to return the scores along with the values.</span>
<span class="sd">        The return type is a list of (value, score) pairs.</span>

<span class="sd">        ``score_cast_func`` a callable used to cast the score return value.</span>

<span class="sd">        ``byscore`` when set to True, returns the range of elements from the</span>
<span class="sd">        sorted set having scores equal or between ``start`` and ``end``.</span>

<span class="sd">        ``bylex`` when set to True, returns the range of elements from the</span>
<span class="sd">        sorted set between the ``start`` and ``end`` lexicographical closed</span>
<span class="sd">        range intervals.</span>
<span class="sd">        Valid ``start`` and ``end`` must start with ( or [, in order to specify</span>
<span class="sd">        whether the range interval is exclusive or inclusive, respectively.</span>

<span class="sd">        ``offset`` and ``num`` are specified, then return a slice of the range.</span>
<span class="sd">        Can&#39;t be provided when using ``bylex``.</span>

<span class="sd">        For more information see https://redis.io/commands/zrange</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Need to support ``desc`` also when using old redis version</span>
        <span class="c1"># because it was supported in 3.5.3 (of redis-py)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">byscore</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">bylex</span> <span class="ow">and</span> <span class="p">(</span><span class="n">offset</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">num</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="n">desc</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">zrevrange</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">withscores</span><span class="p">,</span> <span class="n">score_cast_func</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zrange</span><span class="p">(</span>
            <span class="s2">&quot;ZRANGE&quot;</span><span class="p">,</span>
            <span class="kc">None</span><span class="p">,</span>
            <span class="n">name</span><span class="p">,</span>
            <span class="n">start</span><span class="p">,</span>
            <span class="n">end</span><span class="p">,</span>
            <span class="n">desc</span><span class="p">,</span>
            <span class="n">byscore</span><span class="p">,</span>
            <span class="n">bylex</span><span class="p">,</span>
            <span class="n">withscores</span><span class="p">,</span>
            <span class="n">score_cast_func</span><span class="p">,</span>
            <span class="n">offset</span><span class="p">,</span>
            <span class="n">num</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">zrevrange</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span>
        <span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">end</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">withscores</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">score_cast_func</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">type</span><span class="p">,</span> <span class="n">Callable</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a range of values from sorted set ``name`` between</span>
<span class="sd">        ``start`` and ``end`` sorted in descending order.</span>

<span class="sd">        ``start`` and ``end`` can be negative, indicating the end of the range.</span>

<span class="sd">        ``withscores`` indicates to return the scores along with the values</span>
<span class="sd">        The return type is a list of (value, score) pairs</span>

<span class="sd">        ``score_cast_func`` a callable used to cast the score return value</span>

<span class="sd">        For more information see https://redis.io/commands/zrevrange</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pieces</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;ZREVRANGE&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">withscores</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;WITHSCORES&quot;</span><span class="p">)</span>
        <span class="n">options</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;withscores&quot;</span><span class="p">:</span> <span class="n">withscores</span><span class="p">,</span> <span class="s2">&quot;score_cast_func&quot;</span><span class="p">:</span> <span class="n">score_cast_func</span><span class="p">}</span>
        <span class="n">options</span><span class="p">[</span><span class="s2">&quot;keys&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">name</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="o">*</span><span class="n">pieces</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">zrangestore</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">dest</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span>
        <span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">end</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">byscore</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">bylex</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">desc</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">offset</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">num</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Stores in ``dest`` the result of a range of values from sorted set</span>
<span class="sd">        ``name`` between ``start`` and ``end`` sorted in ascending order.</span>

<span class="sd">        ``start`` and ``end`` can be negative, indicating the end of the range.</span>

<span class="sd">        ``byscore`` when set to True, returns the range of elements from the</span>
<span class="sd">        sorted set having scores equal or between ``start`` and ``end``.</span>

<span class="sd">        ``bylex`` when set to True, returns the range of elements from the</span>
<span class="sd">        sorted set between the ``start`` and ``end`` lexicographical closed</span>
<span class="sd">        range intervals.</span>
<span class="sd">        Valid ``start`` and ``end`` must start with ( or [, in order to specify</span>
<span class="sd">        whether the range interval is exclusive or inclusive, respectively.</span>

<span class="sd">        ``desc`` a boolean indicating whether to sort the results in reversed</span>
<span class="sd">        order.</span>

<span class="sd">        ``offset`` and ``num`` are specified, then return a slice of the range.</span>
<span class="sd">        Can&#39;t be provided when using ``bylex``.</span>

<span class="sd">        For more information see https://redis.io/commands/zrangestore</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zrange</span><span class="p">(</span>
            <span class="s2">&quot;ZRANGESTORE&quot;</span><span class="p">,</span>
            <span class="n">dest</span><span class="p">,</span>
            <span class="n">name</span><span class="p">,</span>
            <span class="n">start</span><span class="p">,</span>
            <span class="n">end</span><span class="p">,</span>
            <span class="n">desc</span><span class="p">,</span>
            <span class="n">byscore</span><span class="p">,</span>
            <span class="n">bylex</span><span class="p">,</span>
            <span class="kc">False</span><span class="p">,</span>
            <span class="kc">None</span><span class="p">,</span>
            <span class="n">offset</span><span class="p">,</span>
            <span class="n">num</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">zrangebylex</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span>
        <span class="nb">min</span><span class="p">:</span> <span class="n">EncodableT</span><span class="p">,</span>
        <span class="nb">max</span><span class="p">:</span> <span class="n">EncodableT</span><span class="p">,</span>
        <span class="n">start</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">num</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the lexicographical range of values from sorted set ``name``</span>
<span class="sd">        between ``min`` and ``max``.</span>

<span class="sd">        If ``start`` and ``num`` are specified, then return a slice of the</span>
<span class="sd">        range.</span>

<span class="sd">        For more information see https://redis.io/commands/zrangebylex</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">num</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">num</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span><span class="s2">&quot;``start`` and ``num`` must both be specified&quot;</span><span class="p">)</span>
        <span class="n">pieces</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;ZRANGEBYLEX&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="nb">min</span><span class="p">,</span> <span class="nb">max</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">num</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="sa">b</span><span class="s2">&quot;LIMIT&quot;</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">num</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="o">*</span><span class="n">pieces</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">zrevrangebylex</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span>
        <span class="nb">max</span><span class="p">:</span> <span class="n">EncodableT</span><span class="p">,</span>
        <span class="nb">min</span><span class="p">:</span> <span class="n">EncodableT</span><span class="p">,</span>
        <span class="n">start</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">num</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the reversed lexicographical range of values from sorted set</span>
<span class="sd">        ``name`` between ``max`` and ``min``.</span>

<span class="sd">        If ``start`` and ``num`` are specified, then return a slice of the</span>
<span class="sd">        range.</span>

<span class="sd">        For more information see https://redis.io/commands/zrevrangebylex</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">num</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">num</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span><span class="s2">&quot;``start`` and ``num`` must both be specified&quot;</span><span class="p">)</span>
        <span class="n">pieces</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;ZREVRANGEBYLEX&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="nb">max</span><span class="p">,</span> <span class="nb">min</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">num</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s2">&quot;LIMIT&quot;</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">num</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="o">*</span><span class="n">pieces</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">zrangebyscore</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span>
        <span class="nb">min</span><span class="p">:</span> <span class="n">ZScoreBoundT</span><span class="p">,</span>
        <span class="nb">max</span><span class="p">:</span> <span class="n">ZScoreBoundT</span><span class="p">,</span>
        <span class="n">start</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">num</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">withscores</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">score_cast_func</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">type</span><span class="p">,</span> <span class="n">Callable</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a range of values from the sorted set ``name`` with scores</span>
<span class="sd">        between ``min`` and ``max``.</span>

<span class="sd">        If ``start`` and ``num`` are specified, then return a slice</span>
<span class="sd">        of the range.</span>

<span class="sd">        ``withscores`` indicates to return the scores along with the values.</span>
<span class="sd">        The return type is a list of (value, score) pairs</span>

<span class="sd">        `score_cast_func`` a callable used to cast the score return value</span>

<span class="sd">        For more information see https://redis.io/commands/zrangebyscore</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">num</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">num</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span><span class="s2">&quot;``start`` and ``num`` must both be specified&quot;</span><span class="p">)</span>
        <span class="n">pieces</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;ZRANGEBYSCORE&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="nb">min</span><span class="p">,</span> <span class="nb">max</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">num</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s2">&quot;LIMIT&quot;</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">num</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">withscores</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;WITHSCORES&quot;</span><span class="p">)</span>
        <span class="n">options</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;withscores&quot;</span><span class="p">:</span> <span class="n">withscores</span><span class="p">,</span> <span class="s2">&quot;score_cast_func&quot;</span><span class="p">:</span> <span class="n">score_cast_func</span><span class="p">}</span>
        <span class="n">options</span><span class="p">[</span><span class="s2">&quot;keys&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="o">*</span><span class="n">pieces</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">zrevrangebyscore</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span>
        <span class="nb">max</span><span class="p">:</span> <span class="n">ZScoreBoundT</span><span class="p">,</span>
        <span class="nb">min</span><span class="p">:</span> <span class="n">ZScoreBoundT</span><span class="p">,</span>
        <span class="n">start</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">num</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">withscores</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">score_cast_func</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">type</span><span class="p">,</span> <span class="n">Callable</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a range of values from the sorted set ``name`` with scores</span>
<span class="sd">        between ``min`` and ``max`` in descending order.</span>

<span class="sd">        If ``start`` and ``num`` are specified, then return a slice</span>
<span class="sd">        of the range.</span>

<span class="sd">        ``withscores`` indicates to return the scores along with the values.</span>
<span class="sd">        The return type is a list of (value, score) pairs</span>

<span class="sd">        ``score_cast_func`` a callable used to cast the score return value</span>

<span class="sd">        For more information see https://redis.io/commands/zrevrangebyscore</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">num</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">num</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span><span class="s2">&quot;``start`` and ``num`` must both be specified&quot;</span><span class="p">)</span>
        <span class="n">pieces</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;ZREVRANGEBYSCORE&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="nb">max</span><span class="p">,</span> <span class="nb">min</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">num</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s2">&quot;LIMIT&quot;</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">num</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">withscores</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;WITHSCORES&quot;</span><span class="p">)</span>
        <span class="n">options</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;withscores&quot;</span><span class="p">:</span> <span class="n">withscores</span><span class="p">,</span> <span class="s2">&quot;score_cast_func&quot;</span><span class="p">:</span> <span class="n">score_cast_func</span><span class="p">}</span>
        <span class="n">options</span><span class="p">[</span><span class="s2">&quot;keys&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="o">*</span><span class="n">pieces</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">zrank</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span>
        <span class="n">value</span><span class="p">:</span> <span class="n">EncodableT</span><span class="p">,</span>
        <span class="n">withscore</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a 0-based value indicating the rank of ``value`` in sorted set</span>
<span class="sd">        ``name``.</span>
<span class="sd">        The optional WITHSCORE argument supplements the command&#39;s</span>
<span class="sd">        reply with the score of the element returned.</span>

<span class="sd">        For more information see https://redis.io/commands/zrank</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">withscore</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;ZRANK&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="s2">&quot;WITHSCORE&quot;</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;ZRANK&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">zrem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span> <span class="o">*</span><span class="n">values</span><span class="p">:</span> <span class="n">FieldT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove member ``values`` from sorted set ``name``</span>

<span class="sd">        For more information see https://redis.io/commands/zrem</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;ZREM&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="n">values</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">zremrangebylex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span> <span class="nb">min</span><span class="p">:</span> <span class="n">EncodableT</span><span class="p">,</span> <span class="nb">max</span><span class="p">:</span> <span class="n">EncodableT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove all elements in the sorted set ``name`` between the</span>
<span class="sd">        lexicographical range specified by ``min`` and ``max``.</span>

<span class="sd">        Returns the number of elements removed.</span>

<span class="sd">        For more information see https://redis.io/commands/zremrangebylex</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;ZREMRANGEBYLEX&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="nb">min</span><span class="p">,</span> <span class="nb">max</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">zremrangebyrank</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span> <span class="nb">min</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">max</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove all elements in the sorted set ``name`` with ranks between</span>
<span class="sd">        ``min`` and ``max``. Values are 0-based, ordered from smallest score</span>
<span class="sd">        to largest. Values can be negative indicating the highest scores.</span>
<span class="sd">        Returns the number of elements removed</span>

<span class="sd">        For more information see https://redis.io/commands/zremrangebyrank</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;ZREMRANGEBYRANK&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="nb">min</span><span class="p">,</span> <span class="nb">max</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">zremrangebyscore</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span> <span class="nb">min</span><span class="p">:</span> <span class="n">ZScoreBoundT</span><span class="p">,</span> <span class="nb">max</span><span class="p">:</span> <span class="n">ZScoreBoundT</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove all elements in the sorted set ``name`` with scores</span>
<span class="sd">        between ``min`` and ``max``. Returns the number of elements removed.</span>

<span class="sd">        For more information see https://redis.io/commands/zremrangebyscore</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;ZREMRANGEBYSCORE&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="nb">min</span><span class="p">,</span> <span class="nb">max</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">zrevrank</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span>
        <span class="n">value</span><span class="p">:</span> <span class="n">EncodableT</span><span class="p">,</span>
        <span class="n">withscore</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a 0-based value indicating the descending rank of</span>
<span class="sd">        ``value`` in sorted set ``name``.</span>
<span class="sd">        The optional ``withscore`` argument supplements the command&#39;s</span>
<span class="sd">        reply with the score of the element returned.</span>

<span class="sd">        For more information see https://redis.io/commands/zrevrank</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">withscore</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span>
                <span class="s2">&quot;ZREVRANK&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="s2">&quot;WITHSCORE&quot;</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;ZREVRANK&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">zscore</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">EncodableT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the score of element ``value`` in sorted set ``name``</span>

<span class="sd">        For more information see https://redis.io/commands/zscore</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;ZSCORE&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">zunion</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">keys</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">KeyT</span><span class="p">],</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">AnyKeyT</span><span class="p">,</span> <span class="nb">float</span><span class="p">]],</span>
        <span class="n">aggregate</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">withscores</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the union of multiple sorted sets specified by ``keys``.</span>
<span class="sd">        ``keys`` can be provided as dictionary of keys and their weights.</span>
<span class="sd">        Scores will be aggregated based on the ``aggregate``, or SUM if</span>
<span class="sd">        none is provided.</span>

<span class="sd">        For more information see https://redis.io/commands/zunion</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zaggregate</span><span class="p">(</span><span class="s2">&quot;ZUNION&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">keys</span><span class="p">,</span> <span class="n">aggregate</span><span class="p">,</span> <span class="n">withscores</span><span class="o">=</span><span class="n">withscores</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">zunionstore</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">dest</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span>
        <span class="n">keys</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">KeyT</span><span class="p">],</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">AnyKeyT</span><span class="p">,</span> <span class="nb">float</span><span class="p">]],</span>
        <span class="n">aggregate</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Union multiple sorted sets specified by ``keys`` into</span>
<span class="sd">        a new sorted set, ``dest``. Scores in the destination will be</span>
<span class="sd">        aggregated based on the ``aggregate``, or SUM if none is provided.</span>

<span class="sd">        For more information see https://redis.io/commands/zunionstore</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zaggregate</span><span class="p">(</span><span class="s2">&quot;ZUNIONSTORE&quot;</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">keys</span><span class="p">,</span> <span class="n">aggregate</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">zmscore</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span> <span class="n">members</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the scores associated with the specified members</span>
<span class="sd">        in the sorted set stored at key.</span>
<span class="sd">        ``members`` should be a list of the member name.</span>
<span class="sd">        Return type is a list of score.</span>
<span class="sd">        If the member does not exist, a None will be returned</span>
<span class="sd">        in corresponding position.</span>

<span class="sd">        For more information see https://redis.io/commands/zmscore</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">members</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span><span class="s2">&quot;ZMSCORE members must be a non-empty list&quot;</span><span class="p">)</span>
        <span class="n">pieces</span> <span class="o">=</span> <span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">+</span> <span class="n">members</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;ZMSCORE&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">pieces</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_zaggregate</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">command</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">dest</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">KeyT</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span>
        <span class="n">keys</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">KeyT</span><span class="p">],</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">AnyKeyT</span><span class="p">,</span> <span class="nb">float</span><span class="p">]],</span>
        <span class="n">aggregate</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">options</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
        <span class="n">pieces</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">EncodableT</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">command</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">dest</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dest</span><span class="p">)</span>
        <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">keys</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="n">keys</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">keys</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">pieces</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">weights</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;WEIGHTS&quot;</span><span class="p">)</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">aggregate</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">aggregate</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;SUM&quot;</span><span class="p">,</span> <span class="s2">&quot;MIN&quot;</span><span class="p">,</span> <span class="s2">&quot;MAX&quot;</span><span class="p">]:</span>
                <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;AGGREGATE&quot;</span><span class="p">)</span>
                <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">aggregate</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span><span class="s2">&quot;aggregate can be sum, min or max.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;withscores&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;WITHSCORES&quot;</span><span class="p">)</span>
        <span class="n">options</span><span class="p">[</span><span class="s2">&quot;keys&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">keys</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="o">*</span><span class="n">pieces</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>


<span class="n">AsyncSortedSetCommands</span> <span class="o">=</span> <span class="n">SortedSetCommands</span>


<span class="k">class</span> <span class="nc">HyperlogCommands</span><span class="p">(</span><span class="n">CommandsProtocol</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Redis commands of HyperLogLogs data type.</span>
<span class="sd">    see: https://redis.io/topics/data-types-intro#hyperloglogs</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">pfadd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span> <span class="o">*</span><span class="n">values</span><span class="p">:</span> <span class="n">FieldT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds the specified elements to the specified HyperLogLog.</span>

<span class="sd">        For more information see https://redis.io/commands/pfadd</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;PFADD&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="n">values</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pfcount</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">sources</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the approximated cardinality of</span>
<span class="sd">        the set observed by the HyperLogLog at key(s).</span>

<span class="sd">        For more information see https://redis.io/commands/pfcount</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;PFCOUNT&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">sources</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pfmerge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dest</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span> <span class="o">*</span><span class="n">sources</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Merge N different HyperLogLogs into a single one.</span>

<span class="sd">        For more information see https://redis.io/commands/pfmerge</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;PFMERGE&quot;</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="o">*</span><span class="n">sources</span><span class="p">)</span>


<span class="n">AsyncHyperlogCommands</span> <span class="o">=</span> <span class="n">HyperlogCommands</span>


<span class="k">class</span> <span class="nc">HashCommands</span><span class="p">(</span><span class="n">CommandsProtocol</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Redis commands for Hash data type.</span>
<span class="sd">    see: https://redis.io/topics/data-types-intro#redis-hashes</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">hdel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">*</span><span class="n">keys</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Awaitable</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Delete ``keys`` from hash ``name``</span>

<span class="sd">        For more information see https://redis.io/commands/hdel</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;HDEL&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="n">keys</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">hexists</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Awaitable</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="nb">bool</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a boolean indicating if ``key`` exists within hash ``name``</span>

<span class="sd">        For more information see https://redis.io/commands/hexists</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;HEXISTS&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">hget</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Awaitable</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the value of ``key`` within the hash ``name``</span>

<span class="sd">        For more information see https://redis.io/commands/hget</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;HGET&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">hgetall</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Awaitable</span><span class="p">[</span><span class="nb">dict</span><span class="p">],</span> <span class="nb">dict</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a Python dict of the hash&#39;s name/value pairs</span>

<span class="sd">        For more information see https://redis.io/commands/hgetall</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;HGETALL&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">hincrby</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">amount</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Awaitable</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Increment the value of ``key`` in hash ``name`` by ``amount``</span>

<span class="sd">        For more information see https://redis.io/commands/hincrby</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;HINCRBY&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">amount</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">hincrbyfloat</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">amount</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Awaitable</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Increment the value of ``key`` in hash ``name`` by floating ``amount``</span>

<span class="sd">        For more information see https://redis.io/commands/hincrbyfloat</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;HINCRBYFLOAT&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">amount</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">hkeys</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Awaitable</span><span class="p">[</span><span class="n">List</span><span class="p">],</span> <span class="n">List</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the list of keys within hash ``name``</span>

<span class="sd">        For more information see https://redis.io/commands/hkeys</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;HKEYS&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">hlen</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Awaitable</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of elements in hash ``name``</span>

<span class="sd">        For more information see https://redis.io/commands/hlen</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;HLEN&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">hset</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">key</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">value</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">mapping</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">items</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Awaitable</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set ``key`` to ``value`` within hash ``name``,</span>
<span class="sd">        ``mapping`` accepts a dict of key/value pairs that will be</span>
<span class="sd">        added to hash ``name``.</span>
<span class="sd">        ``items`` accepts a list of key/value pairs that will be</span>
<span class="sd">        added to hash ``name``.</span>
<span class="sd">        Returns the number of fields that were added.</span>

<span class="sd">        For more information see https://redis.io/commands/hset</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">mapping</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">items</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span><span class="s2">&quot;&#39;hset&#39; with no key value pairs&quot;</span><span class="p">)</span>
        <span class="n">pieces</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">items</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">items</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">extend</span><span class="p">((</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">mapping</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">mapping</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">pieces</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pair</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;HSET&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="n">pieces</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">hsetnx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Awaitable</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="nb">bool</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set ``key`` to ``value`` within hash ``name`` if ``key`` does not</span>
<span class="sd">        exist.  Returns 1 if HSETNX created a field, otherwise 0.</span>

<span class="sd">        For more information see https://redis.io/commands/hsetnx</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;HSETNX&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">hmset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">mapping</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Awaitable</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set key to value within hash ``name`` for each corresponding</span>
<span class="sd">        key and value from the ``mapping`` dict.</span>

<span class="sd">        For more information see https://redis.io/commands/hmset</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.hmset() is deprecated. &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;Use </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.hset() instead.&quot;</span><span class="p">,</span>
            <span class="ne">DeprecationWarning</span><span class="p">,</span>
            <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">mapping</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span><span class="s2">&quot;&#39;hmset&#39; with &#39;mapping&#39; of length 0&quot;</span><span class="p">)</span>
        <span class="n">items</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">mapping</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">items</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pair</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;HMSET&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="n">items</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">hmget</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">keys</span><span class="p">:</span> <span class="n">List</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">List</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Awaitable</span><span class="p">[</span><span class="n">List</span><span class="p">],</span> <span class="n">List</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a list of values ordered identically to ``keys``</span>

<span class="sd">        For more information see https://redis.io/commands/hmget</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">list_or_args</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;HMGET&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">hvals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Awaitable</span><span class="p">[</span><span class="n">List</span><span class="p">],</span> <span class="n">List</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the list of values within hash ``name``</span>

<span class="sd">        For more information see https://redis.io/commands/hvals</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;HVALS&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">hstrlen</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Awaitable</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of bytes stored in the value of ``key``</span>
<span class="sd">        within hash ``name``</span>

<span class="sd">        For more information see https://redis.io/commands/hstrlen</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;HSTRLEN&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">hexpire</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span>
        <span class="n">seconds</span><span class="p">:</span> <span class="n">ExpiryT</span><span class="p">,</span>
        <span class="o">*</span><span class="n">fields</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">nx</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">xx</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">gt</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">lt</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets or updates the expiration time for fields within a hash key, using relative</span>
<span class="sd">        time in seconds.</span>

<span class="sd">        If a field already has an expiration time, the behavior of the update can be</span>
<span class="sd">        controlled using the `nx`, `xx`, `gt`, and `lt` parameters.</span>

<span class="sd">        The return value provides detailed information about the outcome for each field.</span>

<span class="sd">        For more information, see https://redis.io/commands/hexpire</span>

<span class="sd">        Args:</span>
<span class="sd">            name: The name of the hash key.</span>
<span class="sd">            seconds: Expiration time in seconds, relative. Can be an integer, or a</span>
<span class="sd">                     Python `timedelta` object.</span>
<span class="sd">            fields: List of fields within the hash to apply the expiration time to.</span>
<span class="sd">            nx: Set expiry only when the field has no expiry.</span>
<span class="sd">            xx: Set expiry only when the field has an existing expiry.</span>
<span class="sd">            gt: Set expiry only when the new expiry is greater than the current one.</span>
<span class="sd">            lt: Set expiry only when the new expiry is less than the current one.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Returns a list which contains for each field in the request:</span>
<span class="sd">                - `-2` if the field does not exist, or if the key does not exist.</span>
<span class="sd">                - `0` if the specified NX | XX | GT | LT condition was not met.</span>
<span class="sd">                - `1` if the expiration time was set or updated.</span>
<span class="sd">                - `2` if the field was deleted because the specified expiration time is</span>
<span class="sd">                  in the past.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">conditions</span> <span class="o">=</span> <span class="p">[</span><span class="n">nx</span><span class="p">,</span> <span class="n">xx</span><span class="p">,</span> <span class="n">gt</span><span class="p">,</span> <span class="n">lt</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">conditions</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Only one of &#39;nx&#39;, &#39;xx&#39;, &#39;gt&#39;, &#39;lt&#39; can be specified.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">seconds</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">timedelta</span><span class="p">):</span>
            <span class="n">seconds</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">seconds</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">())</span>

        <span class="n">options</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">nx</span><span class="p">:</span>
            <span class="n">options</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;NX&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">xx</span><span class="p">:</span>
            <span class="n">options</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;XX&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">gt</span><span class="p">:</span>
            <span class="n">options</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;GT&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">lt</span><span class="p">:</span>
            <span class="n">options</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;LT&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span>
            <span class="s2">&quot;HEXPIRE&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">seconds</span><span class="p">,</span> <span class="o">*</span><span class="n">options</span><span class="p">,</span> <span class="s2">&quot;FIELDS&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">fields</span><span class="p">),</span> <span class="o">*</span><span class="n">fields</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">hpexpire</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span>
        <span class="n">milliseconds</span><span class="p">:</span> <span class="n">ExpiryT</span><span class="p">,</span>
        <span class="o">*</span><span class="n">fields</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">nx</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">xx</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">gt</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">lt</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets or updates the expiration time for fields within a hash key, using relative</span>
<span class="sd">        time in milliseconds.</span>

<span class="sd">        If a field already has an expiration time, the behavior of the update can be</span>
<span class="sd">        controlled using the `nx`, `xx`, `gt`, and `lt` parameters.</span>

<span class="sd">        The return value provides detailed information about the outcome for each field.</span>

<span class="sd">        For more information, see https://redis.io/commands/hpexpire</span>

<span class="sd">        Args:</span>
<span class="sd">            name: The name of the hash key.</span>
<span class="sd">            milliseconds: Expiration time in milliseconds, relative. Can be an integer,</span>
<span class="sd">                          or a Python `timedelta` object.</span>
<span class="sd">            fields: List of fields within the hash to apply the expiration time to.</span>
<span class="sd">            nx: Set expiry only when the field has no expiry.</span>
<span class="sd">            xx: Set expiry only when the field has an existing expiry.</span>
<span class="sd">            gt: Set expiry only when the new expiry is greater than the current one.</span>
<span class="sd">            lt: Set expiry only when the new expiry is less than the current one.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Returns a list which contains for each field in the request:</span>
<span class="sd">                - `-2` if the field does not exist, or if the key does not exist.</span>
<span class="sd">                - `0` if the specified NX | XX | GT | LT condition was not met.</span>
<span class="sd">                - `1` if the expiration time was set or updated.</span>
<span class="sd">                - `2` if the field was deleted because the specified expiration time is</span>
<span class="sd">                  in the past.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">conditions</span> <span class="o">=</span> <span class="p">[</span><span class="n">nx</span><span class="p">,</span> <span class="n">xx</span><span class="p">,</span> <span class="n">gt</span><span class="p">,</span> <span class="n">lt</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">conditions</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Only one of &#39;nx&#39;, &#39;xx&#39;, &#39;gt&#39;, &#39;lt&#39; can be specified.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">milliseconds</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">timedelta</span><span class="p">):</span>
            <span class="n">milliseconds</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">milliseconds</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">()</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">)</span>

        <span class="n">options</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">nx</span><span class="p">:</span>
            <span class="n">options</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;NX&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">xx</span><span class="p">:</span>
            <span class="n">options</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;XX&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">gt</span><span class="p">:</span>
            <span class="n">options</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;GT&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">lt</span><span class="p">:</span>
            <span class="n">options</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;LT&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span>
            <span class="s2">&quot;HPEXPIRE&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">milliseconds</span><span class="p">,</span> <span class="o">*</span><span class="n">options</span><span class="p">,</span> <span class="s2">&quot;FIELDS&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">fields</span><span class="p">),</span> <span class="o">*</span><span class="n">fields</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">hexpireat</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span>
        <span class="n">unix_time_seconds</span><span class="p">:</span> <span class="n">AbsExpiryT</span><span class="p">,</span>
        <span class="o">*</span><span class="n">fields</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">nx</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">xx</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">gt</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">lt</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets or updates the expiration time for fields within a hash key, using an</span>
<span class="sd">        absolute Unix timestamp in seconds.</span>

<span class="sd">        If a field already has an expiration time, the behavior of the update can be</span>
<span class="sd">        controlled using the `nx`, `xx`, `gt`, and `lt` parameters.</span>

<span class="sd">        The return value provides detailed information about the outcome for each field.</span>

<span class="sd">        For more information, see https://redis.io/commands/hexpireat</span>

<span class="sd">        Args:</span>
<span class="sd">            name: The name of the hash key.</span>
<span class="sd">            unix_time_seconds: Expiration time as Unix timestamp in seconds. Can be an</span>
<span class="sd">                               integer or a Python `datetime` object.</span>
<span class="sd">            fields: List of fields within the hash to apply the expiration time to.</span>
<span class="sd">            nx: Set expiry only when the field has no expiry.</span>
<span class="sd">            xx: Set expiry only when the field has an existing expiration time.</span>
<span class="sd">            gt: Set expiry only when the new expiry is greater than the current one.</span>
<span class="sd">            lt: Set expiry only when the new expiry is less than the current one.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Returns a list which contains for each field in the request:</span>
<span class="sd">                - `-2` if the field does not exist, or if the key does not exist.</span>
<span class="sd">                - `0` if the specified NX | XX | GT | LT condition was not met.</span>
<span class="sd">                - `1` if the expiration time was set or updated.</span>
<span class="sd">                - `2` if the field was deleted because the specified expiration time is</span>
<span class="sd">                  in the past.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">conditions</span> <span class="o">=</span> <span class="p">[</span><span class="n">nx</span><span class="p">,</span> <span class="n">xx</span><span class="p">,</span> <span class="n">gt</span><span class="p">,</span> <span class="n">lt</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">conditions</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Only one of &#39;nx&#39;, &#39;xx&#39;, &#39;gt&#39;, &#39;lt&#39; can be specified.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">unix_time_seconds</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">):</span>
            <span class="n">unix_time_seconds</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">unix_time_seconds</span><span class="o">.</span><span class="n">timestamp</span><span class="p">())</span>

        <span class="n">options</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">nx</span><span class="p">:</span>
            <span class="n">options</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;NX&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">xx</span><span class="p">:</span>
            <span class="n">options</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;XX&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">gt</span><span class="p">:</span>
            <span class="n">options</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;GT&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">lt</span><span class="p">:</span>
            <span class="n">options</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;LT&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span>
            <span class="s2">&quot;HEXPIREAT&quot;</span><span class="p">,</span>
            <span class="n">name</span><span class="p">,</span>
            <span class="n">unix_time_seconds</span><span class="p">,</span>
            <span class="o">*</span><span class="n">options</span><span class="p">,</span>
            <span class="s2">&quot;FIELDS&quot;</span><span class="p">,</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">fields</span><span class="p">),</span>
            <span class="o">*</span><span class="n">fields</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">hpexpireat</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span>
        <span class="n">unix_time_milliseconds</span><span class="p">:</span> <span class="n">AbsExpiryT</span><span class="p">,</span>
        <span class="o">*</span><span class="n">fields</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">nx</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">xx</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">gt</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">lt</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets or updates the expiration time for fields within a hash key, using an</span>
<span class="sd">        absolute Unix timestamp in milliseconds.</span>

<span class="sd">        If a field already has an expiration time, the behavior of the update can be</span>
<span class="sd">        controlled using the `nx`, `xx`, `gt`, and `lt` parameters.</span>

<span class="sd">        The return value provides detailed information about the outcome for each field.</span>

<span class="sd">        For more information, see https://redis.io/commands/hpexpireat</span>

<span class="sd">        Args:</span>
<span class="sd">            name: The name of the hash key.</span>
<span class="sd">            unix_time_milliseconds: Expiration time as Unix timestamp in milliseconds.</span>
<span class="sd">                                    Can be an integer or a Python `datetime` object.</span>
<span class="sd">            fields: List of fields within the hash to apply the expiry.</span>
<span class="sd">            nx: Set expiry only when the field has no expiry.</span>
<span class="sd">            xx: Set expiry only when the field has an existing expiry.</span>
<span class="sd">            gt: Set expiry only when the new expiry is greater than the current one.</span>
<span class="sd">            lt: Set expiry only when the new expiry is less than the current one.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Returns a list which contains for each field in the request:</span>
<span class="sd">                - `-2` if the field does not exist, or if the key does not exist.</span>
<span class="sd">                - `0` if the specified NX | XX | GT | LT condition was not met.</span>
<span class="sd">                - `1` if the expiration time was set or updated.</span>
<span class="sd">                - `2` if the field was deleted because the specified expiration time is</span>
<span class="sd">                  in the past.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">conditions</span> <span class="o">=</span> <span class="p">[</span><span class="n">nx</span><span class="p">,</span> <span class="n">xx</span><span class="p">,</span> <span class="n">gt</span><span class="p">,</span> <span class="n">lt</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">conditions</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Only one of &#39;nx&#39;, &#39;xx&#39;, &#39;gt&#39;, &#39;lt&#39; can be specified.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">unix_time_milliseconds</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">):</span>
            <span class="n">unix_time_milliseconds</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">unix_time_milliseconds</span><span class="o">.</span><span class="n">timestamp</span><span class="p">()</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">)</span>

        <span class="n">options</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">nx</span><span class="p">:</span>
            <span class="n">options</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;NX&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">xx</span><span class="p">:</span>
            <span class="n">options</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;XX&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">gt</span><span class="p">:</span>
            <span class="n">options</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;GT&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">lt</span><span class="p">:</span>
            <span class="n">options</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;LT&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span>
            <span class="s2">&quot;HPEXPIREAT&quot;</span><span class="p">,</span>
            <span class="n">name</span><span class="p">,</span>
            <span class="n">unix_time_milliseconds</span><span class="p">,</span>
            <span class="o">*</span><span class="n">options</span><span class="p">,</span>
            <span class="s2">&quot;FIELDS&quot;</span><span class="p">,</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">fields</span><span class="p">),</span>
            <span class="o">*</span><span class="n">fields</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">hpersist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span> <span class="o">*</span><span class="n">fields</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes the expiration time for each specified field in a hash.</span>

<span class="sd">        For more information, see https://redis.io/commands/hpersist</span>

<span class="sd">        Args:</span>
<span class="sd">            name: The name of the hash key.</span>
<span class="sd">            fields: A list of fields within the hash from which to remove the</span>
<span class="sd">                    expiration time.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Returns a list which contains for each field in the request:</span>
<span class="sd">                - `-2` if the field does not exist, or if the key does not exist.</span>
<span class="sd">                - `-1` if the field exists but has no associated expiration time.</span>
<span class="sd">                - `1` if the expiration time was successfully removed from the field.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;HPERSIST&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="s2">&quot;FIELDS&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">fields</span><span class="p">),</span> <span class="o">*</span><span class="n">fields</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">hexpiretime</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span> <span class="o">*</span><span class="n">fields</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the expiration times of hash fields as Unix timestamps in seconds.</span>

<span class="sd">        For more information, see https://redis.io/commands/hexpiretime</span>

<span class="sd">        Args:</span>
<span class="sd">            key: The hash key.</span>
<span class="sd">            fields: A list of fields within the hash for which to get the expiration</span>
<span class="sd">                    time.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Returns a list which contains for each field in the request:</span>
<span class="sd">                - `-2` if the field does not exist, or if the key does not exist.</span>
<span class="sd">                - `-1` if the field exists but has no associated expire time.</span>
<span class="sd">                - A positive integer representing the expiration Unix timestamp in</span>
<span class="sd">                  seconds, if the field has an associated expiration time.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span>
            <span class="s2">&quot;HEXPIRETIME&quot;</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="s2">&quot;FIELDS&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">fields</span><span class="p">),</span> <span class="o">*</span><span class="n">fields</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">hpexpiretime</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span> <span class="o">*</span><span class="n">fields</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the expiration times of hash fields as Unix timestamps in milliseconds.</span>

<span class="sd">        For more information, see https://redis.io/commands/hpexpiretime</span>

<span class="sd">        Args:</span>
<span class="sd">            key: The hash key.</span>
<span class="sd">            fields: A list of fields within the hash for which to get the expiration</span>
<span class="sd">                    time.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Returns a list which contains for each field in the request:</span>
<span class="sd">                - `-2` if the field does not exist, or if the key does not exist.</span>
<span class="sd">                - `-1` if the field exists but has no associated expire time.</span>
<span class="sd">                - A positive integer representing the expiration Unix timestamp in</span>
<span class="sd">                  milliseconds, if the field has an associated expiration time.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span>
            <span class="s2">&quot;HPEXPIRETIME&quot;</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="s2">&quot;FIELDS&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">fields</span><span class="p">),</span> <span class="o">*</span><span class="n">fields</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">httl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span> <span class="o">*</span><span class="n">fields</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the TTL (Time To Live) in seconds for each specified field within a hash</span>
<span class="sd">        key.</span>

<span class="sd">        For more information, see https://redis.io/commands/httl</span>

<span class="sd">        Args:</span>
<span class="sd">            key: The hash key.</span>
<span class="sd">            fields: A list of fields within the hash for which to get the TTL.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Returns a list which contains for each field in the request:</span>
<span class="sd">                - `-2` if the field does not exist, or if the key does not exist.</span>
<span class="sd">                - `-1` if the field exists but has no associated expire time.</span>
<span class="sd">                - A positive integer representing the TTL in seconds if the field has</span>
<span class="sd">                  an associated expiration time.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span>
            <span class="s2">&quot;HTTL&quot;</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="s2">&quot;FIELDS&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">fields</span><span class="p">),</span> <span class="o">*</span><span class="n">fields</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">hpttl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span> <span class="o">*</span><span class="n">fields</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the TTL (Time To Live) in milliseconds for each specified field within a</span>
<span class="sd">        hash key.</span>

<span class="sd">        For more information, see https://redis.io/commands/hpttl</span>

<span class="sd">        Args:</span>
<span class="sd">            key: The hash key.</span>
<span class="sd">            fields: A list of fields within the hash for which to get the TTL.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Returns a list which contains for each field in the request:</span>
<span class="sd">                - `-2` if the field does not exist, or if the key does not exist.</span>
<span class="sd">                - `-1` if the field exists but has no associated expire time.</span>
<span class="sd">                - A positive integer representing the TTL in milliseconds if the field</span>
<span class="sd">                  has an associated expiration time.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span>
            <span class="s2">&quot;HPTTL&quot;</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="s2">&quot;FIELDS&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">fields</span><span class="p">),</span> <span class="o">*</span><span class="n">fields</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="p">)</span>


<span class="n">AsyncHashCommands</span> <span class="o">=</span> <span class="n">HashCommands</span>


<span class="k">class</span> <span class="nc">Script</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An executable Lua script object returned by ``register_script``</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">registered_client</span><span class="p">:</span> <span class="s2">&quot;redis.client.Redis&quot;</span><span class="p">,</span> <span class="n">script</span><span class="p">:</span> <span class="n">ScriptTextT</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">registered_client</span> <span class="o">=</span> <span class="n">registered_client</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">script</span> <span class="o">=</span> <span class="n">script</span>
        <span class="c1"># Precalculate and store the SHA1 hex digest of the script.</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">script</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="c1"># We need the encoding from the client in order to generate an</span>
            <span class="c1"># accurate byte representation of the script</span>
            <span class="n">encoder</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_encoder</span><span class="p">()</span>
            <span class="n">script</span> <span class="o">=</span> <span class="n">encoder</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">script</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sha</span> <span class="o">=</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">sha1</span><span class="p">(</span><span class="n">script</span><span class="p">)</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">keys</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">KeyT</span><span class="p">],</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">args</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="n">EncodableT</span><span class="p">],</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">client</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="s2">&quot;redis.client.Redis&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Execute the script, passing any required ``args``&quot;&quot;&quot;</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="n">keys</span> <span class="ow">or</span> <span class="p">[]</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">args</span> <span class="ow">or</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">client</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">client</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">registered_client</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="c1"># make sure the Redis server knows about the script</span>
        <span class="kn">from</span> <span class="nn">redis.client</span> <span class="kn">import</span> <span class="n">Pipeline</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">Pipeline</span><span class="p">):</span>
            <span class="c1"># Make sure the pipeline can register the script before executing.</span>
            <span class="n">client</span><span class="o">.</span><span class="n">scripts</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">client</span><span class="o">.</span><span class="n">evalsha</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sha</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">),</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">NoScriptError</span><span class="p">:</span>
            <span class="c1"># Maybe the client is pointed to a different server than the client</span>
            <span class="c1"># that created this instance?</span>
            <span class="c1"># Overwrite the sha just in case there was a discrepancy.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sha</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">script_load</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">script</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">client</span><span class="o">.</span><span class="n">evalsha</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sha</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">),</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_encoder</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the encoder to encode string scripts into bytes.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">registered_client</span><span class="o">.</span><span class="n">get_encoder</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="c1"># DEPRECATED</span>
            <span class="c1"># In version &lt;=4.1.2, this was the code we used to get the encoder.</span>
            <span class="c1"># However, after 4.1.2 we added support for scripting in clustered</span>
            <span class="c1"># redis. ClusteredRedis doesn&#39;t have a `.connection_pool` attribute</span>
            <span class="c1"># so we changed the Script class to use</span>
            <span class="c1"># `self.registered_client.get_encoder` (see above).</span>
            <span class="c1"># However, that is technically a breaking change, as consumers who</span>
            <span class="c1"># use Scripts directly might inject a `registered_client` that</span>
            <span class="c1"># doesn&#39;t have a `.get_encoder` field. This try/except prevents us</span>
            <span class="c1"># from breaking backward-compatibility. Ideally, it would be</span>
            <span class="c1"># removed in the next major release.</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">registered_client</span><span class="o">.</span><span class="n">connection_pool</span><span class="o">.</span><span class="n">get_encoder</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">AsyncScript</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An executable Lua script object returned by ``register_script``</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">registered_client</span><span class="p">:</span> <span class="s2">&quot;redis.asyncio.client.Redis&quot;</span><span class="p">,</span>
        <span class="n">script</span><span class="p">:</span> <span class="n">ScriptTextT</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">registered_client</span> <span class="o">=</span> <span class="n">registered_client</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">script</span> <span class="o">=</span> <span class="n">script</span>
        <span class="c1"># Precalculate and store the SHA1 hex digest of the script.</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">script</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="c1"># We need the encoding from the client in order to generate an</span>
            <span class="c1"># accurate byte representation of the script</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">encoder</span> <span class="o">=</span> <span class="n">registered_client</span><span class="o">.</span><span class="n">connection_pool</span><span class="o">.</span><span class="n">get_encoder</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="c1"># Cluster</span>
                <span class="n">encoder</span> <span class="o">=</span> <span class="n">registered_client</span><span class="o">.</span><span class="n">get_encoder</span><span class="p">()</span>
            <span class="n">script</span> <span class="o">=</span> <span class="n">encoder</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">script</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sha</span> <span class="o">=</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">sha1</span><span class="p">(</span><span class="n">script</span><span class="p">)</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>

    <span class="k">async</span> <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">keys</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">KeyT</span><span class="p">],</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">args</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="n">EncodableT</span><span class="p">],</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">client</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="s2">&quot;redis.asyncio.client.Redis&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Execute the script, passing any required ``args``&quot;&quot;&quot;</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="n">keys</span> <span class="ow">or</span> <span class="p">[]</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">args</span> <span class="ow">or</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">client</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">client</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">registered_client</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="c1"># make sure the Redis server knows about the script</span>
        <span class="kn">from</span> <span class="nn">redis.asyncio.client</span> <span class="kn">import</span> <span class="n">Pipeline</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">Pipeline</span><span class="p">):</span>
            <span class="c1"># Make sure the pipeline can register the script before executing.</span>
            <span class="n">client</span><span class="o">.</span><span class="n">scripts</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="k">await</span> <span class="n">client</span><span class="o">.</span><span class="n">evalsha</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sha</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">),</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">NoScriptError</span><span class="p">:</span>
            <span class="c1"># Maybe the client is pointed to a different server than the client</span>
            <span class="c1"># that created this instance?</span>
            <span class="c1"># Overwrite the sha just in case there was a discrepancy.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sha</span> <span class="o">=</span> <span class="k">await</span> <span class="n">client</span><span class="o">.</span><span class="n">script_load</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">script</span><span class="p">)</span>
            <span class="k">return</span> <span class="k">await</span> <span class="n">client</span><span class="o">.</span><span class="n">evalsha</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sha</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">),</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">PubSubCommands</span><span class="p">(</span><span class="n">CommandsProtocol</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Redis PubSub commands.</span>
<span class="sd">    see https://redis.io/topics/pubsub</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">publish</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channel</span><span class="p">:</span> <span class="n">ChannelT</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span> <span class="n">EncodableT</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Publish ``message`` on ``channel``.</span>
<span class="sd">        Returns the number of subscribers the message was delivered to.</span>

<span class="sd">        For more information see https://redis.io/commands/publish</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;PUBLISH&quot;</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">spublish</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shard_channel</span><span class="p">:</span> <span class="n">ChannelT</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span> <span class="n">EncodableT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Posts a message to the given shard channel.</span>
<span class="sd">        Returns the number of clients that received the message</span>

<span class="sd">        For more information see https://redis.io/commands/spublish</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;SPUBLISH&quot;</span><span class="p">,</span> <span class="n">shard_channel</span><span class="p">,</span> <span class="n">message</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pubsub_channels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pattern</span><span class="p">:</span> <span class="n">PatternT</span> <span class="o">=</span> <span class="s2">&quot;*&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list of channels that have at least one subscriber</span>

<span class="sd">        For more information see https://redis.io/commands/pubsub-channels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;PUBSUB CHANNELS&quot;</span><span class="p">,</span> <span class="n">pattern</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pubsub_shardchannels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pattern</span><span class="p">:</span> <span class="n">PatternT</span> <span class="o">=</span> <span class="s2">&quot;*&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list of shard_channels that have at least one subscriber</span>

<span class="sd">        For more information see https://redis.io/commands/pubsub-shardchannels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;PUBSUB SHARDCHANNELS&quot;</span><span class="p">,</span> <span class="n">pattern</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pubsub_numpat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of subscriptions to patterns</span>

<span class="sd">        For more information see https://redis.io/commands/pubsub-numpat</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;PUBSUB NUMPAT&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pubsub_numsub</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">ChannelT</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list of (channel, number of subscribers) tuples</span>
<span class="sd">        for each channel given in ``*args``</span>

<span class="sd">        For more information see https://redis.io/commands/pubsub-numsub</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;PUBSUB NUMSUB&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pubsub_shardnumsub</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">ChannelT</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list of (shard_channel, number of subscribers) tuples</span>
<span class="sd">        for each channel given in ``*args``</span>

<span class="sd">        For more information see https://redis.io/commands/pubsub-shardnumsub</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;PUBSUB SHARDNUMSUB&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="n">AsyncPubSubCommands</span> <span class="o">=</span> <span class="n">PubSubCommands</span>


<span class="k">class</span> <span class="nc">ScriptCommands</span><span class="p">(</span><span class="n">CommandsProtocol</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Redis Lua script commands. see:</span>
<span class="sd">    https://redis.io/ebook/part-3-next-steps/chapter-11-scripting-redis-with-lua/</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_eval</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">command</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">script</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">numkeys</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="o">*</span><span class="n">keys_and_args</span><span class="p">:</span> <span class="nb">str</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Awaitable</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">]:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="n">script</span><span class="p">,</span> <span class="n">numkeys</span><span class="p">,</span> <span class="o">*</span><span class="n">keys_and_args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">script</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">numkeys</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="o">*</span><span class="n">keys_and_args</span><span class="p">:</span> <span class="nb">str</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Awaitable</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Execute the Lua ``script``, specifying the ``numkeys`` the script</span>
<span class="sd">        will touch and the key names and argument values in ``keys_and_args``.</span>
<span class="sd">        Returns the result of the script.</span>

<span class="sd">        In practice, use the object returned by ``register_script``. This</span>
<span class="sd">        function exists purely for Redis API completion.</span>

<span class="sd">        For more information see  https://redis.io/commands/eval</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval</span><span class="p">(</span><span class="s2">&quot;EVAL&quot;</span><span class="p">,</span> <span class="n">script</span><span class="p">,</span> <span class="n">numkeys</span><span class="p">,</span> <span class="o">*</span><span class="n">keys_and_args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">eval_ro</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">script</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">numkeys</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="o">*</span><span class="n">keys_and_args</span><span class="p">:</span> <span class="nb">str</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Awaitable</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The read-only variant of the EVAL command</span>

<span class="sd">        Execute the read-only Lua ``script`` specifying the ``numkeys`` the script</span>
<span class="sd">        will touch and the key names and argument values in ``keys_and_args``.</span>
<span class="sd">        Returns the result of the script.</span>

<span class="sd">        For more information see  https://redis.io/commands/eval_ro</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval</span><span class="p">(</span><span class="s2">&quot;EVAL_RO&quot;</span><span class="p">,</span> <span class="n">script</span><span class="p">,</span> <span class="n">numkeys</span><span class="p">,</span> <span class="o">*</span><span class="n">keys_and_args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_evalsha</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">command</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">sha</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">numkeys</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="o">*</span><span class="n">keys_and_args</span><span class="p">:</span> <span class="nb">list</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Awaitable</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">]:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="n">sha</span><span class="p">,</span> <span class="n">numkeys</span><span class="p">,</span> <span class="o">*</span><span class="n">keys_and_args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">evalsha</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">sha</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">numkeys</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="o">*</span><span class="n">keys_and_args</span><span class="p">:</span> <span class="nb">str</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Awaitable</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Use the ``sha`` to execute a Lua script already registered via EVAL</span>
<span class="sd">        or SCRIPT LOAD. Specify the ``numkeys`` the script will touch and the</span>
<span class="sd">        key names and argument values in ``keys_and_args``. Returns the result</span>
<span class="sd">        of the script.</span>

<span class="sd">        In practice, use the object returned by ``register_script``. This</span>
<span class="sd">        function exists purely for Redis API completion.</span>

<span class="sd">        For more information see  https://redis.io/commands/evalsha</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_evalsha</span><span class="p">(</span><span class="s2">&quot;EVALSHA&quot;</span><span class="p">,</span> <span class="n">sha</span><span class="p">,</span> <span class="n">numkeys</span><span class="p">,</span> <span class="o">*</span><span class="n">keys_and_args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">evalsha_ro</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">sha</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">numkeys</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="o">*</span><span class="n">keys_and_args</span><span class="p">:</span> <span class="nb">str</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Awaitable</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The read-only variant of the EVALSHA command</span>

<span class="sd">        Use the ``sha`` to execute a read-only Lua script already registered via EVAL</span>
<span class="sd">        or SCRIPT LOAD. Specify the ``numkeys`` the script will touch and the</span>
<span class="sd">        key names and argument values in ``keys_and_args``. Returns the result</span>
<span class="sd">        of the script.</span>

<span class="sd">        For more information see  https://redis.io/commands/evalsha_ro</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_evalsha</span><span class="p">(</span><span class="s2">&quot;EVALSHA_RO&quot;</span><span class="p">,</span> <span class="n">sha</span><span class="p">,</span> <span class="n">numkeys</span><span class="p">,</span> <span class="o">*</span><span class="n">keys_and_args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">script_exists</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if a script exists in the script cache by specifying the SHAs of</span>
<span class="sd">        each script as ``args``. Returns a list of boolean values indicating if</span>
<span class="sd">        if each already script exists in the cache_data.</span>

<span class="sd">        For more information see  https://redis.io/commands/script-exists</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;SCRIPT EXISTS&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">script_debug</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;SCRIPT DEBUG is intentionally not implemented in the client.&quot;</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">script_flush</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">sync_type</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;SYNC&quot;</span><span class="p">],</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;ASYNC&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Flush all scripts from the script cache_data.</span>

<span class="sd">        ``sync_type`` is by default SYNC (synchronous) but it can also be</span>
<span class="sd">                      ASYNC.</span>

<span class="sd">        For more information see  https://redis.io/commands/script-flush</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Redis pre 6 had no sync_type.</span>
        <span class="k">if</span> <span class="n">sync_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;SYNC&quot;</span><span class="p">,</span> <span class="s2">&quot;ASYNC&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span>
                <span class="s2">&quot;SCRIPT FLUSH defaults to SYNC in redis &gt; 6.2, or &quot;</span>
                <span class="s2">&quot;accepts SYNC/ASYNC. For older versions, &quot;</span>
                <span class="s2">&quot;of redis leave as None.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">sync_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pieces</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pieces</span> <span class="o">=</span> <span class="p">[</span><span class="n">sync_type</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;SCRIPT FLUSH&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">pieces</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">script_kill</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Kill the currently executing Lua script</span>

<span class="sd">        For more information see https://redis.io/commands/script-kill</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;SCRIPT KILL&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">script_load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">script</span><span class="p">:</span> <span class="n">ScriptTextT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load a Lua ``script`` into the script cache_data. Returns the SHA.</span>

<span class="sd">        For more information see https://redis.io/commands/script-load</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;SCRIPT LOAD&quot;</span><span class="p">,</span> <span class="n">script</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">register_script</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="s2">&quot;redis.client.Redis&quot;</span><span class="p">,</span> <span class="n">script</span><span class="p">:</span> <span class="n">ScriptTextT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Script</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Register a Lua ``script`` specifying the ``keys`` it will touch.</span>
<span class="sd">        Returns a Script object that is callable and hides the complexity of</span>
<span class="sd">        deal with scripts, keys, and shas. This is the preferred way to work</span>
<span class="sd">        with Lua scripts.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Script</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">script</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">AsyncScriptCommands</span><span class="p">(</span><span class="n">ScriptCommands</span><span class="p">):</span>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">script_debug</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">script_debug</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">register_script</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="s2">&quot;redis.asyncio.client.Redis&quot;</span><span class="p">,</span>
        <span class="n">script</span><span class="p">:</span> <span class="n">ScriptTextT</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AsyncScript</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Register a Lua ``script`` specifying the ``keys`` it will touch.</span>
<span class="sd">        Returns a Script object that is callable and hides the complexity of</span>
<span class="sd">        deal with scripts, keys, and shas. This is the preferred way to work</span>
<span class="sd">        with Lua scripts.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">AsyncScript</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">script</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">GeoCommands</span><span class="p">(</span><span class="n">CommandsProtocol</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Redis Geospatial commands.</span>
<span class="sd">    see: https://redis.com/redis-best-practices/indexing-patterns/geospatial/</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">geoadd</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span>
        <span class="n">values</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">EncodableT</span><span class="p">],</span>
        <span class="n">nx</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">xx</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">ch</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add the specified geospatial items to the specified key identified</span>
<span class="sd">        by the ``name`` argument. The Geospatial items are given as ordered</span>
<span class="sd">        members of the ``values`` argument, each item or place is formed by</span>
<span class="sd">        the triad longitude, latitude and name.</span>

<span class="sd">        Note: You can use ZREM to remove elements.</span>

<span class="sd">        ``nx`` forces ZADD to only create new elements and not to update</span>
<span class="sd">        scores for elements that already exist.</span>

<span class="sd">        ``xx`` forces ZADD to only update scores of elements that already</span>
<span class="sd">        exist. New elements will not be added.</span>

<span class="sd">        ``ch`` modifies the return value to be the numbers of elements changed.</span>
<span class="sd">        Changed elements include new elements that were added and elements</span>
<span class="sd">        whose scores changed.</span>

<span class="sd">        For more information see https://redis.io/commands/geoadd</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">nx</span> <span class="ow">and</span> <span class="n">xx</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span><span class="s2">&quot;GEOADD allows either &#39;nx&#39; or &#39;xx&#39;, not both&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span><span class="s2">&quot;GEOADD requires places with lon, lat and name values&quot;</span><span class="p">)</span>
        <span class="n">pieces</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">nx</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;NX&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">xx</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;XX&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ch</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;CH&quot;</span><span class="p">)</span>
        <span class="n">pieces</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;GEOADD&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">pieces</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">geodist</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span> <span class="n">place1</span><span class="p">:</span> <span class="n">FieldT</span><span class="p">,</span> <span class="n">place2</span><span class="p">:</span> <span class="n">FieldT</span><span class="p">,</span> <span class="n">unit</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the distance between ``place1`` and ``place2`` members of the</span>
<span class="sd">        ``name`` key.</span>
<span class="sd">        The units must be one of the following : m, km mi, ft. By default</span>
<span class="sd">        meters are used.</span>

<span class="sd">        For more information see https://redis.io/commands/geodist</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pieces</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">EncodableT</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span><span class="p">,</span> <span class="n">place1</span><span class="p">,</span> <span class="n">place2</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">unit</span> <span class="ow">and</span> <span class="n">unit</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;m&quot;</span><span class="p">,</span> <span class="s2">&quot;km&quot;</span><span class="p">,</span> <span class="s2">&quot;mi&quot;</span><span class="p">,</span> <span class="s2">&quot;ft&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span><span class="s2">&quot;GEODIST invalid unit&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">unit</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;GEODIST&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">pieces</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">geohash</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span> <span class="o">*</span><span class="n">values</span><span class="p">:</span> <span class="n">FieldT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the geo hash string for each item of ``values`` members of</span>
<span class="sd">        the specified key identified by the ``name`` argument.</span>

<span class="sd">        For more information see https://redis.io/commands/geohash</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;GEOHASH&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="n">values</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">geopos</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span> <span class="o">*</span><span class="n">values</span><span class="p">:</span> <span class="n">FieldT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the positions of each item of ``values`` as members of</span>
<span class="sd">        the specified key identified by the ``name`` argument. Each position</span>
<span class="sd">        is represented by the pairs lon and lat.</span>

<span class="sd">        For more information see https://redis.io/commands/geopos</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;GEOPOS&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="n">values</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">georadius</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span>
        <span class="n">longitude</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">latitude</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">radius</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">unit</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">withdist</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">withcoord</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">withhash</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">count</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">sort</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">store</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">KeyT</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">store_dist</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">KeyT</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="nb">any</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the members of the specified key identified by the</span>
<span class="sd">        ``name`` argument which are within the borders of the area specified</span>
<span class="sd">        with the ``latitude`` and ``longitude`` location and the maximum</span>
<span class="sd">        distance from the center specified by the ``radius`` value.</span>

<span class="sd">        The units must be one of the following : m, km mi, ft. By default</span>

<span class="sd">        ``withdist`` indicates to return the distances of each place.</span>

<span class="sd">        ``withcoord`` indicates to return the latitude and longitude of</span>
<span class="sd">        each place.</span>

<span class="sd">        ``withhash`` indicates to return the geohash string of each place.</span>

<span class="sd">        ``count`` indicates to return the number of elements up to N.</span>

<span class="sd">        ``sort`` indicates to return the places in a sorted way, ASC for</span>
<span class="sd">        nearest to fairest and DESC for fairest to nearest.</span>

<span class="sd">        ``store`` indicates to save the places names in a sorted set named</span>
<span class="sd">        with a specific key, each element of the destination sorted set is</span>
<span class="sd">        populated with the score got from the original geo sorted set.</span>

<span class="sd">        ``store_dist`` indicates to save the places names in a sorted set</span>
<span class="sd">        named with a specific key, instead of ``store`` the sorted set</span>
<span class="sd">        destination score is set with the distance.</span>

<span class="sd">        For more information see https://redis.io/commands/georadius</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_georadiusgeneric</span><span class="p">(</span>
            <span class="s2">&quot;GEORADIUS&quot;</span><span class="p">,</span>
            <span class="n">name</span><span class="p">,</span>
            <span class="n">longitude</span><span class="p">,</span>
            <span class="n">latitude</span><span class="p">,</span>
            <span class="n">radius</span><span class="p">,</span>
            <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">,</span>
            <span class="n">withdist</span><span class="o">=</span><span class="n">withdist</span><span class="p">,</span>
            <span class="n">withcoord</span><span class="o">=</span><span class="n">withcoord</span><span class="p">,</span>
            <span class="n">withhash</span><span class="o">=</span><span class="n">withhash</span><span class="p">,</span>
            <span class="n">count</span><span class="o">=</span><span class="n">count</span><span class="p">,</span>
            <span class="n">sort</span><span class="o">=</span><span class="n">sort</span><span class="p">,</span>
            <span class="n">store</span><span class="o">=</span><span class="n">store</span><span class="p">,</span>
            <span class="n">store_dist</span><span class="o">=</span><span class="n">store_dist</span><span class="p">,</span>
            <span class="nb">any</span><span class="o">=</span><span class="nb">any</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">georadiusbymember</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span>
        <span class="n">member</span><span class="p">:</span> <span class="n">FieldT</span><span class="p">,</span>
        <span class="n">radius</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">unit</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">withdist</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">withcoord</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">withhash</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">count</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">sort</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">store</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">KeyT</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">store_dist</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">KeyT</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="nb">any</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This command is exactly like ``georadius`` with the sole difference</span>
<span class="sd">        that instead of taking, as the center of the area to query, a longitude</span>
<span class="sd">        and latitude value, it takes the name of a member already existing</span>
<span class="sd">        inside the geospatial index represented by the sorted set.</span>

<span class="sd">        For more information see https://redis.io/commands/georadiusbymember</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_georadiusgeneric</span><span class="p">(</span>
            <span class="s2">&quot;GEORADIUSBYMEMBER&quot;</span><span class="p">,</span>
            <span class="n">name</span><span class="p">,</span>
            <span class="n">member</span><span class="p">,</span>
            <span class="n">radius</span><span class="p">,</span>
            <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">,</span>
            <span class="n">withdist</span><span class="o">=</span><span class="n">withdist</span><span class="p">,</span>
            <span class="n">withcoord</span><span class="o">=</span><span class="n">withcoord</span><span class="p">,</span>
            <span class="n">withhash</span><span class="o">=</span><span class="n">withhash</span><span class="p">,</span>
            <span class="n">count</span><span class="o">=</span><span class="n">count</span><span class="p">,</span>
            <span class="n">sort</span><span class="o">=</span><span class="n">sort</span><span class="p">,</span>
            <span class="n">store</span><span class="o">=</span><span class="n">store</span><span class="p">,</span>
            <span class="n">store_dist</span><span class="o">=</span><span class="n">store_dist</span><span class="p">,</span>
            <span class="nb">any</span><span class="o">=</span><span class="nb">any</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_georadiusgeneric</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">command</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">EncodableT</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">EncodableT</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
        <span class="n">pieces</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;unit&quot;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;unit&quot;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;m&quot;</span><span class="p">,</span> <span class="s2">&quot;km&quot;</span><span class="p">,</span> <span class="s2">&quot;mi&quot;</span><span class="p">,</span> <span class="s2">&quot;ft&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span><span class="s2">&quot;GEORADIUS invalid unit&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;unit&quot;</span><span class="p">]:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;unit&quot;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;m&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;any&quot;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span><span class="s2">&quot;``any`` can&#39;t be provided without ``count``&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">arg_name</span><span class="p">,</span> <span class="n">byte_repr</span> <span class="ow">in</span> <span class="p">(</span>
            <span class="p">(</span><span class="s2">&quot;withdist&quot;</span><span class="p">,</span> <span class="s2">&quot;WITHDIST&quot;</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;withcoord&quot;</span><span class="p">,</span> <span class="s2">&quot;WITHCOORD&quot;</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;withhash&quot;</span><span class="p">,</span> <span class="s2">&quot;WITHHASH&quot;</span><span class="p">),</span>
        <span class="p">):</span>
            <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">arg_name</span><span class="p">]:</span>
                <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">byte_repr</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s2">&quot;COUNT&quot;</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">]])</span>
            <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;any&quot;</span><span class="p">]:</span>
                <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;ANY&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;sort&quot;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;sort&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;ASC&quot;</span><span class="p">:</span>
                <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;ASC&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;sort&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;DESC&quot;</span><span class="p">:</span>
                <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;DESC&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span><span class="s2">&quot;GEORADIUS invalid sort&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;store&quot;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;store_dist&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span><span class="s2">&quot;GEORADIUS store and store_dist cant be set together&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;store&quot;</span><span class="p">]:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="sa">b</span><span class="s2">&quot;STORE&quot;</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;store&quot;</span><span class="p">]])</span>

        <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;store_dist&quot;</span><span class="p">]:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="sa">b</span><span class="s2">&quot;STOREDIST&quot;</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;store_dist&quot;</span><span class="p">]])</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="o">*</span><span class="n">pieces</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">geosearch</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span>
        <span class="n">member</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">FieldT</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">longitude</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">latitude</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">unit</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;m&quot;</span><span class="p">,</span>
        <span class="n">radius</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">width</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">height</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">sort</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">count</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="nb">any</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">withcoord</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">withdist</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">withhash</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the members of specified key identified by the</span>
<span class="sd">        ``name`` argument, which are within the borders of the</span>
<span class="sd">        area specified by a given shape. This command extends the</span>
<span class="sd">        GEORADIUS command, so in addition to searching within circular</span>
<span class="sd">        areas, it supports searching within rectangular areas.</span>

<span class="sd">        This command should be used in place of the deprecated</span>
<span class="sd">        GEORADIUS and GEORADIUSBYMEMBER commands.</span>

<span class="sd">        ``member`` Use the position of the given existing</span>
<span class="sd">         member in the sorted set. Can&#39;t be given with ``longitude``</span>
<span class="sd">         and ``latitude``.</span>

<span class="sd">        ``longitude`` and ``latitude`` Use the position given by</span>
<span class="sd">        this coordinates. Can&#39;t be given with ``member``</span>
<span class="sd">        ``radius`` Similar to GEORADIUS, search inside circular</span>
<span class="sd">        area according the given radius. Can&#39;t be given with</span>
<span class="sd">        ``height`` and ``width``.</span>
<span class="sd">        ``height`` and ``width`` Search inside an axis-aligned</span>
<span class="sd">        rectangle, determined by the given height and width.</span>
<span class="sd">        Can&#39;t be given with ``radius``</span>

<span class="sd">        ``unit`` must be one of the following : m, km, mi, ft.</span>
<span class="sd">        `m` for meters (the default value), `km` for kilometers,</span>
<span class="sd">        `mi` for miles and `ft` for feet.</span>

<span class="sd">        ``sort`` indicates to return the places in a sorted way,</span>
<span class="sd">        ASC for nearest to furthest and DESC for furthest to nearest.</span>

<span class="sd">        ``count`` limit the results to the first count matching items.</span>

<span class="sd">        ``any`` is set to True, the command will return as soon as</span>
<span class="sd">        enough matches are found. Can&#39;t be provided without ``count``</span>

<span class="sd">        ``withdist`` indicates to return the distances of each place.</span>
<span class="sd">        ``withcoord`` indicates to return the latitude and longitude of</span>
<span class="sd">        each place.</span>

<span class="sd">        ``withhash`` indicates to return the geohash string of each place.</span>

<span class="sd">        For more information see https://redis.io/commands/geosearch</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_geosearchgeneric</span><span class="p">(</span>
            <span class="s2">&quot;GEOSEARCH&quot;</span><span class="p">,</span>
            <span class="n">name</span><span class="p">,</span>
            <span class="n">member</span><span class="o">=</span><span class="n">member</span><span class="p">,</span>
            <span class="n">longitude</span><span class="o">=</span><span class="n">longitude</span><span class="p">,</span>
            <span class="n">latitude</span><span class="o">=</span><span class="n">latitude</span><span class="p">,</span>
            <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">,</span>
            <span class="n">radius</span><span class="o">=</span><span class="n">radius</span><span class="p">,</span>
            <span class="n">width</span><span class="o">=</span><span class="n">width</span><span class="p">,</span>
            <span class="n">height</span><span class="o">=</span><span class="n">height</span><span class="p">,</span>
            <span class="n">sort</span><span class="o">=</span><span class="n">sort</span><span class="p">,</span>
            <span class="n">count</span><span class="o">=</span><span class="n">count</span><span class="p">,</span>
            <span class="nb">any</span><span class="o">=</span><span class="nb">any</span><span class="p">,</span>
            <span class="n">withcoord</span><span class="o">=</span><span class="n">withcoord</span><span class="p">,</span>
            <span class="n">withdist</span><span class="o">=</span><span class="n">withdist</span><span class="p">,</span>
            <span class="n">withhash</span><span class="o">=</span><span class="n">withhash</span><span class="p">,</span>
            <span class="n">store</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">store_dist</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">geosearchstore</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">dest</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="n">KeyT</span><span class="p">,</span>
        <span class="n">member</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">FieldT</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">longitude</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">latitude</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">unit</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;m&quot;</span><span class="p">,</span>
        <span class="n">radius</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">width</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">height</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">sort</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">count</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="nb">any</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">storedist</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This command is like GEOSEARCH, but stores the result in</span>
<span class="sd">        ``dest``. By default, it stores the results in the destination</span>
<span class="sd">        sorted set with their geospatial information.</span>
<span class="sd">        if ``store_dist`` set to True, the command will stores the</span>
<span class="sd">        items in a sorted set populated with their distance from the</span>
<span class="sd">        center of the circle or box, as a floating-point number.</span>

<span class="sd">        For more information see https://redis.io/commands/geosearchstore</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_geosearchgeneric</span><span class="p">(</span>
            <span class="s2">&quot;GEOSEARCHSTORE&quot;</span><span class="p">,</span>
            <span class="n">dest</span><span class="p">,</span>
            <span class="n">name</span><span class="p">,</span>
            <span class="n">member</span><span class="o">=</span><span class="n">member</span><span class="p">,</span>
            <span class="n">longitude</span><span class="o">=</span><span class="n">longitude</span><span class="p">,</span>
            <span class="n">latitude</span><span class="o">=</span><span class="n">latitude</span><span class="p">,</span>
            <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">,</span>
            <span class="n">radius</span><span class="o">=</span><span class="n">radius</span><span class="p">,</span>
            <span class="n">width</span><span class="o">=</span><span class="n">width</span><span class="p">,</span>
            <span class="n">height</span><span class="o">=</span><span class="n">height</span><span class="p">,</span>
            <span class="n">sort</span><span class="o">=</span><span class="n">sort</span><span class="p">,</span>
            <span class="n">count</span><span class="o">=</span><span class="n">count</span><span class="p">,</span>
            <span class="nb">any</span><span class="o">=</span><span class="nb">any</span><span class="p">,</span>
            <span class="n">withcoord</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">withdist</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">withhash</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">store</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">store_dist</span><span class="o">=</span><span class="n">storedist</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_geosearchgeneric</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">command</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">EncodableT</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">EncodableT</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
        <span class="n">pieces</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

        <span class="c1"># FROMMEMBER or FROMLONLAT</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;member&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;longitude&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;latitude&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span><span class="s2">&quot;GEOSEARCH must have member or longitude and latitude&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;member&quot;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;longitude&quot;</span><span class="p">]</span> <span class="ow">or</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;latitude&quot;</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span>
                    <span class="s2">&quot;GEOSEARCH member and longitude or latitude cant be set together&quot;</span>
                <span class="p">)</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="sa">b</span><span class="s2">&quot;FROMMEMBER&quot;</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;member&quot;</span><span class="p">]])</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;longitude&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;latitude&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="sa">b</span><span class="s2">&quot;FROMLONLAT&quot;</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;longitude&quot;</span><span class="p">],</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;latitude&quot;</span><span class="p">]])</span>

        <span class="c1"># BYRADIUS or BYBOX</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;radius&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;width&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;height&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span><span class="s2">&quot;GEOSEARCH must have radius or width and height&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;unit&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span><span class="s2">&quot;GEOSEARCH must have unit&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;unit&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;m&quot;</span><span class="p">,</span> <span class="s2">&quot;km&quot;</span><span class="p">,</span> <span class="s2">&quot;mi&quot;</span><span class="p">,</span> <span class="s2">&quot;ft&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span><span class="s2">&quot;GEOSEARCH invalid unit&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;radius&quot;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;width&quot;</span><span class="p">]</span> <span class="ow">or</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;height&quot;</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span>
                    <span class="s2">&quot;GEOSEARCH radius and width or height cant be set together&quot;</span>
                <span class="p">)</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="sa">b</span><span class="s2">&quot;BYRADIUS&quot;</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;radius&quot;</span><span class="p">],</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;unit&quot;</span><span class="p">]])</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;width&quot;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;height&quot;</span><span class="p">]:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="sa">b</span><span class="s2">&quot;BYBOX&quot;</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;width&quot;</span><span class="p">],</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;height&quot;</span><span class="p">],</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;unit&quot;</span><span class="p">]])</span>

        <span class="c1"># sort</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;sort&quot;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;sort&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;ASC&quot;</span><span class="p">:</span>
                <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;ASC&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;sort&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;DESC&quot;</span><span class="p">:</span>
                <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;DESC&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span><span class="s2">&quot;GEOSEARCH invalid sort&quot;</span><span class="p">)</span>

        <span class="c1"># count any</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">]:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="sa">b</span><span class="s2">&quot;COUNT&quot;</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">]])</span>
            <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;any&quot;</span><span class="p">]:</span>
                <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;ANY&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;any&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span><span class="s2">&quot;GEOSEARCH ``any`` can&#39;t be provided without count&quot;</span><span class="p">)</span>

        <span class="c1"># other properties</span>
        <span class="k">for</span> <span class="n">arg_name</span><span class="p">,</span> <span class="n">byte_repr</span> <span class="ow">in</span> <span class="p">(</span>
            <span class="p">(</span><span class="s2">&quot;withdist&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;WITHDIST&quot;</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;withcoord&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;WITHCOORD&quot;</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;withhash&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;WITHHASH&quot;</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;store_dist&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;STOREDIST&quot;</span><span class="p">),</span>
        <span class="p">):</span>
            <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">arg_name</span><span class="p">]:</span>
                <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">byte_repr</span><span class="p">)</span>

        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;keys&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">command</span> <span class="o">==</span> <span class="s2">&quot;GEOSEARCH&quot;</span> <span class="k">else</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="o">*</span><span class="n">pieces</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="n">AsyncGeoCommands</span> <span class="o">=</span> <span class="n">GeoCommands</span>


<span class="k">class</span> <span class="nc">ModuleCommands</span><span class="p">(</span><span class="n">CommandsProtocol</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Redis Module commands.</span>
<span class="sd">    see: https://redis.io/topics/modules-intro</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">module_load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loads the module from ``path``.</span>
<span class="sd">        Passes all ``*args`` to the module, during loading.</span>
<span class="sd">        Raises ``ModuleError`` if a module is not found at ``path``.</span>

<span class="sd">        For more information see https://redis.io/commands/module-load</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;MODULE LOAD&quot;</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">module_loadex</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">options</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">args</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loads a module from a dynamic library at runtime with configuration directives.</span>

<span class="sd">        For more information see https://redis.io/commands/module-loadex</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pieces</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">options</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;CONFIG&quot;</span><span class="p">)</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">options</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">args</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;ARGS&quot;</span><span class="p">)</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;MODULE LOADEX&quot;</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="o">*</span><span class="n">pieces</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">module_unload</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Unloads the module ``name``.</span>
<span class="sd">        Raises ``ModuleError`` if ``name`` is not in loaded modules.</span>

<span class="sd">        For more information see https://redis.io/commands/module-unload</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;MODULE UNLOAD&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">module_list</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a list of dictionaries containing the name and version of</span>
<span class="sd">        all loaded modules.</span>

<span class="sd">        For more information see https://redis.io/commands/module-list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;MODULE LIST&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">command_info</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;COMMAND INFO is intentionally not implemented in the client.&quot;</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">command_count</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;COMMAND COUNT&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">command_getkeys</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;COMMAND GETKEYS&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">command</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;COMMAND&quot;</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">AsyncModuleCommands</span><span class="p">(</span><span class="n">ModuleCommands</span><span class="p">):</span>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">command_info</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">command_info</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">ClusterCommands</span><span class="p">(</span><span class="n">CommandsProtocol</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class for Redis Cluster commands</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">cluster</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster_arg</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;CLUSTER </span><span class="si">{</span><span class="n">cluster_arg</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">readwrite</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Disables read queries for a connection to a Redis Cluster slave node.</span>

<span class="sd">        For more information see https://redis.io/commands/readwrite</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;READWRITE&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">readonly</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Enables read queries for a connection to a Redis Cluster replica node.</span>

<span class="sd">        For more information see https://redis.io/commands/readonly</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;READONLY&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="n">AsyncClusterCommands</span> <span class="o">=</span> <span class="n">ClusterCommands</span>


<span class="k">class</span> <span class="nc">FunctionCommands</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Redis Function commands</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">function_load</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">code</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">replace</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Awaitable</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load a library to Redis.</span>
<span class="sd">        :param code: the source code (must start with</span>
<span class="sd">        Shebang statement that provides a metadata about the library)</span>
<span class="sd">        :param replace: changes the behavior to overwrite the existing library</span>
<span class="sd">        with the new contents.</span>
<span class="sd">        Return the library name that was loaded.</span>

<span class="sd">        For more information see https://redis.io/commands/function-load</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pieces</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;REPLACE&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="n">replace</span> <span class="k">else</span> <span class="p">[]</span>
        <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">code</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;FUNCTION LOAD&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">pieces</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">function_delete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">library</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Awaitable</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Delete the library called ``library`` and all its functions.</span>

<span class="sd">        For more information see https://redis.io/commands/function-delete</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;FUNCTION DELETE&quot;</span><span class="p">,</span> <span class="n">library</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">function_flush</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;SYNC&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Awaitable</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Deletes all the libraries.</span>

<span class="sd">        For more information see https://redis.io/commands/function-flush</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;FUNCTION FLUSH&quot;</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">function_list</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">library</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;*&quot;</span><span class="p">,</span> <span class="n">withcode</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Awaitable</span><span class="p">[</span><span class="n">List</span><span class="p">],</span> <span class="n">List</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return information about the functions and libraries.</span>

<span class="sd">        Args:</span>

<span class="sd">            library: specify a pattern for matching library names</span>
<span class="sd">            withcode: cause the server to include the libraries source implementation</span>
<span class="sd">                in the reply</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;LIBRARYNAME&quot;</span><span class="p">,</span> <span class="n">library</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">withcode</span><span class="p">:</span>
            <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;WITHCODE&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;FUNCTION LIST&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_fcall</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">command</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">numkeys</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="o">*</span><span class="n">keys_and_args</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Awaitable</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">]:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">numkeys</span><span class="p">,</span> <span class="o">*</span><span class="n">keys_and_args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">fcall</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">numkeys</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="o">*</span><span class="n">keys_and_args</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Awaitable</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Invoke a function.</span>

<span class="sd">        For more information see https://redis.io/commands/fcall</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fcall</span><span class="p">(</span><span class="s2">&quot;FCALL&quot;</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">numkeys</span><span class="p">,</span> <span class="o">*</span><span class="n">keys_and_args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">fcall_ro</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">numkeys</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="o">*</span><span class="n">keys_and_args</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Awaitable</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is a read-only variant of the FCALL command that cannot</span>
<span class="sd">        execute commands that modify data.</span>

<span class="sd">        For more information see https://redis.io/commands/fcal_ro</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fcall</span><span class="p">(</span><span class="s2">&quot;FCALL_RO&quot;</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">numkeys</span><span class="p">,</span> <span class="o">*</span><span class="n">keys_and_args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">function_dump</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Awaitable</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the serialized payload of loaded libraries.</span>

<span class="sd">        For more information see https://redis.io/commands/function-dump</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">redis.client</span> <span class="kn">import</span> <span class="n">NEVER_DECODE</span>

        <span class="n">options</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">options</span><span class="p">[</span><span class="n">NEVER_DECODE</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;FUNCTION DUMP&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">function_restore</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">payload</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">policy</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;APPEND&quot;</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Awaitable</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Restore libraries from the serialized ``payload``.</span>
<span class="sd">        You can use the optional policy argument to provide a policy</span>
<span class="sd">        for handling existing libraries.</span>

<span class="sd">        For more information see https://redis.io/commands/function-restore</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;FUNCTION RESTORE&quot;</span><span class="p">,</span> <span class="n">payload</span><span class="p">,</span> <span class="n">policy</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">function_kill</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Awaitable</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Kill a function that is currently executing.</span>

<span class="sd">        For more information see https://redis.io/commands/function-kill</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;FUNCTION KILL&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">function_stats</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Awaitable</span><span class="p">[</span><span class="n">List</span><span class="p">],</span> <span class="n">List</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return information about the function that&#39;s currently running</span>
<span class="sd">        and information about the available execution engines.</span>

<span class="sd">        For more information see https://redis.io/commands/function-stats</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;FUNCTION STATS&quot;</span><span class="p">)</span>


<span class="n">AsyncFunctionCommands</span> <span class="o">=</span> <span class="n">FunctionCommands</span>


<span class="k">class</span> <span class="nc">GearsCommands</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">tfunction_load</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">lib_code</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">replace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">config</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load a new library to RedisGears.</span>

<span class="sd">        ``lib_code`` - the library code.</span>
<span class="sd">        ``config`` - a string representation of a JSON object</span>
<span class="sd">        that will be provided to the library on load time,</span>
<span class="sd">        for more information refer to</span>
<span class="sd">        https://github.com/RedisGears/RedisGears/blob/master/docs/function_advance_topics.md#library-configuration</span>
<span class="sd">        ``replace`` - an optional argument, instructs RedisGears to replace the</span>
<span class="sd">        function if its already exists</span>

<span class="sd">        For more information see https://redis.io/commands/tfunction-load/</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pieces</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">replace</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;REPLACE&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">config</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s2">&quot;CONFIG&quot;</span><span class="p">,</span> <span class="n">config</span><span class="p">])</span>
        <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lib_code</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;TFUNCTION LOAD&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">pieces</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">tfunction_delete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lib_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Delete a library from RedisGears.</span>

<span class="sd">        ``lib_name`` the library name to delete.</span>

<span class="sd">        For more information see https://redis.io/commands/tfunction-delete/</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;TFUNCTION DELETE&quot;</span><span class="p">,</span> <span class="n">lib_name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">tfunction_list</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">with_code</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">lib_name</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        List the functions with additional information about each function.</span>

<span class="sd">        ``with_code`` Show libraries code.</span>
<span class="sd">        ``verbose`` output verbosity level, higher number will increase verbosity level</span>
<span class="sd">        ``lib_name`` specifying a library name (can be used multiple times to show multiple libraries in a single command) # noqa</span>

<span class="sd">        For more information see https://redis.io/commands/tfunction-list/</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pieces</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">with_code</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;WITHCODE&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">verbose</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;v&quot;</span> <span class="o">*</span> <span class="n">verbose</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span><span class="s2">&quot;verbose can be 1, 2 or 3&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">lib_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;LIBRARY&quot;</span><span class="p">)</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lib_name</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;TFUNCTION LIST&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">pieces</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_tfcall</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">lib_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">func_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">keys</span><span class="p">:</span> <span class="n">KeysT</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">_async</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">List</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
        <span class="n">pieces</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">lib_name</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">func_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">keys</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">))</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">args</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">_async</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;TFCALLASYNC&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">pieces</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_command</span><span class="p">(</span><span class="s2">&quot;TFCALL&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">pieces</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">tfcall</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">lib_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">func_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">keys</span><span class="p">:</span> <span class="n">KeysT</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">List</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Invoke a function.</span>

<span class="sd">        ``lib_name`` - the library name contains the function.</span>
<span class="sd">        ``func_name`` - the function name to run.</span>
<span class="sd">        ``keys`` - the keys that will be touched by the function.</span>
<span class="sd">        ``args`` - Additional argument to pass to the function.</span>

<span class="sd">        For more information see https://redis.io/commands/tfcall/</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tfcall</span><span class="p">(</span><span class="n">lib_name</span><span class="p">,</span> <span class="n">func_name</span><span class="p">,</span> <span class="n">keys</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">tfcall_async</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">lib_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">func_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">keys</span><span class="p">:</span> <span class="n">KeysT</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">List</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResponseT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Invoke an async function (coroutine).</span>

<span class="sd">        ``lib_name`` - the library name contains the function.</span>
<span class="sd">        ``func_name`` - the function name to run.</span>
<span class="sd">        ``keys`` - the keys that will be touched by the function.</span>
<span class="sd">        ``args`` - Additional argument to pass to the function.</span>

<span class="sd">        For more information see https://redis.io/commands/tfcall/</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tfcall</span><span class="p">(</span><span class="n">lib_name</span><span class="p">,</span> <span class="n">func_name</span><span class="p">,</span> <span class="n">keys</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


<span class="n">AsyncGearsCommands</span> <span class="o">=</span> <span class="n">GearsCommands</span>


<span class="k">class</span> <span class="nc">DataAccessCommands</span><span class="p">(</span>
    <span class="n">BasicKeyCommands</span><span class="p">,</span>
    <span class="n">HyperlogCommands</span><span class="p">,</span>
    <span class="n">HashCommands</span><span class="p">,</span>
    <span class="n">GeoCommands</span><span class="p">,</span>
    <span class="n">ListCommands</span><span class="p">,</span>
    <span class="n">ScanCommands</span><span class="p">,</span>
    <span class="n">SetCommands</span><span class="p">,</span>
    <span class="n">StreamCommands</span><span class="p">,</span>
    <span class="n">SortedSetCommands</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class containing all of the implemented data access redis commands.</span>
<span class="sd">    This class is to be used as a mixin for synchronous Redis clients.</span>
<span class="sd">    &quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">AsyncDataAccessCommands</span><span class="p">(</span>
    <span class="n">AsyncBasicKeyCommands</span><span class="p">,</span>
    <span class="n">AsyncHyperlogCommands</span><span class="p">,</span>
    <span class="n">AsyncHashCommands</span><span class="p">,</span>
    <span class="n">AsyncGeoCommands</span><span class="p">,</span>
    <span class="n">AsyncListCommands</span><span class="p">,</span>
    <span class="n">AsyncScanCommands</span><span class="p">,</span>
    <span class="n">AsyncSetCommands</span><span class="p">,</span>
    <span class="n">AsyncStreamCommands</span><span class="p">,</span>
    <span class="n">AsyncSortedSetCommands</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class containing all of the implemented data access redis commands.</span>
<span class="sd">    This class is to be used as a mixin for asynchronous Redis clients.</span>
<span class="sd">    &quot;&quot;&quot;</span>


<div class="viewcode-block" id="CoreCommands">
<a class="viewcode-back" href="../../../commands/core.html#redis.commands.core.CoreCommands">[文档]</a>
<span class="k">class</span> <span class="nc">CoreCommands</span><span class="p">(</span>
    <span class="n">ACLCommands</span><span class="p">,</span>
    <span class="n">ClusterCommands</span><span class="p">,</span>
    <span class="n">DataAccessCommands</span><span class="p">,</span>
    <span class="n">ManagementCommands</span><span class="p">,</span>
    <span class="n">ModuleCommands</span><span class="p">,</span>
    <span class="n">PubSubCommands</span><span class="p">,</span>
    <span class="n">ScriptCommands</span><span class="p">,</span>
    <span class="n">FunctionCommands</span><span class="p">,</span>
    <span class="n">GearsCommands</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class containing all of the implemented redis commands. This class is</span>
<span class="sd">    to be used as a mixin for synchronous Redis clients.</span>
<span class="sd">    &quot;&quot;&quot;</span></div>



<span class="k">class</span> <span class="nc">AsyncCoreCommands</span><span class="p">(</span>
    <span class="n">AsyncACLCommands</span><span class="p">,</span>
    <span class="n">AsyncClusterCommands</span><span class="p">,</span>
    <span class="n">AsyncDataAccessCommands</span><span class="p">,</span>
    <span class="n">AsyncManagementCommands</span><span class="p">,</span>
    <span class="n">AsyncModuleCommands</span><span class="p">,</span>
    <span class="n">AsyncPubSubCommands</span><span class="p">,</span>
    <span class="n">AsyncScriptCommands</span><span class="p">,</span>
    <span class="n">AsyncFunctionCommands</span><span class="p">,</span>
    <span class="n">AsyncGearsCommands</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class containing all of the implemented redis commands. This class is</span>
<span class="sd">    to be used as a mixin for asynchronous Redis clients.</span>
<span class="sd">    &quot;&quot;&quot;</span>
</pre></div>
        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2024, Redis Inc
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            <div class="icons">
              <a class="muted-link " href="https://github.com/redis/redis-py" aria-label="GitHub">
            <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16">
                <path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z"></path>
            </svg>
        </a>
              
            </div>
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer no-toc">
      
      
      
    </aside>
  </div>
</div><script src="../../../_static/documentation_options.js?v=91cf81b4"></script>
    <script src="../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/scripts/furo.js?v=5fa4622c"></script>
    <script src="../../../_static/translations.js?v=beaddf03"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    </body>
</html>